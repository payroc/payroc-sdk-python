# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.custom_pagination import AsyncPayrocPager, SyncPayrocPager
from ...core.datetime_utils import serialize_datetime
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_nine import FourHundredNine
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.funding_account import FundingAccount
from ...types.order_item import OrderItem
from ...types.owner import Owner
from ...types.paginated_contacts import PaginatedContacts
from ...types.paginated_owners import PaginatedOwners
from ...types.paginated_processing_terminals import PaginatedProcessingTerminals
from ...types.processing_account import ProcessingAccount
from ...types.processing_terminal import ProcessingTerminal
from ...types.terminal_order import TerminalOrder
from ...types.training_provider import TrainingProvider
from .types.create_reminder_processing_accounts_request_body import CreateReminderProcessingAccountsRequestBody
from .types.create_reminder_processing_accounts_response import CreateReminderProcessingAccountsResponse
from .types.create_terminal_order_shipping import CreateTerminalOrderShipping
from .types.get_processing_account_pricing_agreement_processing_accounts_response import (
    GetProcessingAccountPricingAgreementProcessingAccountsResponse,
)
from .types.list_terminal_orders_processing_accounts_request_status import (
    ListTerminalOrdersProcessingAccountsRequestStatus,
)

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawProcessingAccountsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def retrieve(
        self, processing_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ProcessingAccount]:
        """
        Use this method to retrieve information about a specific processing account.

        To retrieve a processing account, you need its processingAccountId. Our gateway returned the processingAccountId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method or the [Create Processing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        **Note:** If you don't have the processingAccountId, use our [List Merchant Platform's Processing Accounts](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list-processing-accounts) method to search for the processing account.

        Our gateway returns the following information about the processing account:

        -    Business information, including the Merchant Category Code (MCC), status of the processing account, and address of the business.
        -    Processing information, including the merchant’s refund policies and card types that the merchant accepts.
        -    Funding information, including funding schedules, funding fees, and details for the merchant’s funding accounts.
        -    Pricing information, including [HATEOAS](https://docs.payroc.com/knowledge/basic-concepts/hypermedia-as-the-engine-of-application-state-hateoas) links to retrieve the pricing program for the processing account.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ProcessingAccount]
            Successful request. Returns the processing account.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProcessingAccount,
                    parse_obj_as(
                        type_=ProcessingAccount,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_processing_account_funding_accounts(
        self, processing_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[FundingAccount]]:
        """
        Use this method to return a list of funding accounts linked to a processing acccount.

        To retrieve a list of funding accounts for a processing account, you need the processingAccountId. Our gateway returned the processingAccountId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method or the [Create Proccessing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        Our gateway returns information about the following for each funding account in the list:
        - Account information, including the name on the account and payment methods.
        - Status, including whether we have approved or rejected the account.

        For each funding account, we also return its fundingAccountId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[FundingAccount]]
            Successful request. Returns a list of funding accounts associated with the processing account.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/funding-accounts",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[FundingAccount],
                    parse_obj_as(
                        type_=typing.List[FundingAccount],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_contacts(
        self,
        processing_account_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaginatedContacts]:
        """
        Use this method to return a list of contacts for a processing account.

        **Note:** If you want to view the details of a specific contact and you have their contactId, use our [Retrieve Contact](https://docs.payroc.com/api/schema/boarding/contacts/retrieve) method.

        To list contacts for a processing account, you need the processingAccountId. Our gateway returned the processingAccountId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method or the [Create Processing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        Our gateway returns the following information about each contact:

        - Name and contact method, including their phone number or mobile number.
        - Role within the business, for example, if they are a manager.

        For each contact, we also return a contactId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaginatedContacts]
            Successful request. Returns a list of contacts associated with the processing account.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/contacts",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedContacts,
                    parse_obj_as(
                        type_=PaginatedContacts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_processing_account_pricing_agreement(
        self, processing_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetProcessingAccountPricingAgreementProcessingAccountsResponse]:
        """
        Use this method to retrieve the pricing agreement that we apply to a processing account.

        To retrieve the pricing agreement of a processing account, you need the processingAccountId. Our gateway returned the processingAccountId in the response to the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method and [Create Processing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        **Note:** If you don't have the processingAccountId, use our [List Merchant Platform’s Processing Accounts](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list-processing-accounts) method to search for the processing account.

        Our gateway returns the following information about the pricing agreement that we apply to the processing account:

        - Base fees, including the annual fee and the fees for each chargeback and retrieval.
        - Processor fees, including the fees that we apply for processing card and ACH payments.
        - Gateway fees, including the setup fee and the fees for each transaction.
        - Service fees, including the fee that we apply if the merchant has signed up to a Hardware Advantage Plan.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetProcessingAccountPricingAgreementProcessingAccountsResponse]
            Successful request. We return a polymorphic object that contains the pricing agreement for the processing account.

            The value of the version field determines which variant you should use:
            -    `4.0` - Pricing agreement version 4.
            -    `5.0` - Pricing agreement version 5.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/pricing",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProcessingAccountPricingAgreementProcessingAccountsResponse,
                    parse_obj_as(
                        type_=GetProcessingAccountPricingAgreementProcessingAccountsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_owners(
        self,
        processing_account_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[Owner, PaginatedOwners]:
        """
        Use this method to return a list of owners of a processing account.

        **Note:** If you want to view the details of a specific owner and you have the ownerId, go to our [Retrieve Owner](https://docs.payroc.com/api/schema/boarding/owners/retrieve) method.

        To list the owners of a processing account, you need its processingAccountId. If you don't have the processingAccountId, use our [List Merchant Platform's Processing Accounts](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list-processing-accounts) method to search for the processing account.

        Our gateway returns the following information about each owner in the list:

        - Name, date of birth, and address.
        - Contact details, including their email address.
        - Relationship to the business, including whether they are a control prong or authorized signatory, and their equity stake in the business.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[Owner, PaginatedOwners]
            Successful request. Returns a list of owners associated with the processing account.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/owners",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedOwners,
                    parse_obj_as(
                        type_=PaginatedOwners,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_reminder(
        self,
        processing_account_id: str,
        *,
        idempotency_key: str,
        request: CreateReminderProcessingAccountsRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateReminderProcessingAccountsResponse]:
        """
        Use this method to prompt a merchant to sign their pricing agreement.

        You can create a reminder only if you requested the merchant’s signature by email when you created the processing account for the merchant.

        To create a reminder, you need the processingAccountId. Our gateway returned the processingAccountId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method or [Create Processing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        **Note:** If you don’t know the processingAccountId, use our [List Merchant Platform’s Processing Accounts](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list-processing-accounts) method to search for the processing account.

        When you send a successful request, we send an email to the merchant that prompts them to sign their pricing agreement.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : CreateReminderProcessingAccountsRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateReminderProcessingAccountsResponse]
            Successful request. We sent an email to the merchant and we return a polymorphic object that contains reminder details.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/reminders",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=CreateReminderProcessingAccountsRequestBody, direction="write"
            ),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateReminderProcessingAccountsResponse,
                    parse_obj_as(
                        type_=CreateReminderProcessingAccountsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_terminal_orders(
        self,
        processing_account_id: str,
        *,
        status: typing.Optional[ListTerminalOrdersProcessingAccountsRequestStatus] = None,
        from_date_time: typing.Optional[dt.datetime] = None,
        to_date_time: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[TerminalOrder]]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of terminal orders associated with a processing account.

        **Note:** If you want to view the details of a specific terminal order and you have its terminalOrderId, use our [Retrieve Terminal Order](https://docs.payroc.com/api/schema/boarding/terminal-orders/retrieve) method.

        Use the query parameters to filter the list of results that we return, for example, to search for terminal orders by their status.

        To list the terminal orders for a processing account, you need its processingAccountId. If you don't have the processingAccountId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for a merchant platform and its processing accounts.

        Our gateway returns the following information for each terminal order in the list:

        - Status of the order
        - Items in the order
        - Training provider
        - Shipping information

        For each terminal order, we also return its terminalOrderId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        status : typing.Optional[ListTerminalOrdersProcessingAccountsRequestStatus]

        from_date_time : typing.Optional[dt.datetime]

        to_date_time : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[TerminalOrder]]
            Successful request. Returns a list of terminal orders associated with the processing account.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/terminal-orders",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "status": status,
                "fromDateTime": serialize_datetime(from_date_time) if from_date_time is not None else None,
                "toDateTime": serialize_datetime(to_date_time) if to_date_time is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TerminalOrder],
                    parse_obj_as(
                        type_=typing.List[TerminalOrder],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_terminal_order(
        self,
        processing_account_id: str,
        *,
        idempotency_key: str,
        order_items: typing.Sequence[OrderItem],
        training_provider: typing.Optional[TrainingProvider] = OMIT,
        shipping: typing.Optional[CreateTerminalOrderShipping] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TerminalOrder]:
        """
        Use this method to order and configure terminals for a processing account.

        **Note**: You need the ID of the processing account before you can create an order. If you don't know the processingAccountId, go to the [Retrieve a Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/retrieve) method.

        In the request, specify the gateway settings, device settings, and application settings for the terminal.

        In the response, our gateway returns information about the terminal order including its status and terminalOrderId that you can use to [retrieve the terminal order](https://docs.payroc.com/api/schema/boarding/terminal-orders/retrieve).

        **Note**: You can subscribe to the terminalOrder.status.changed event to get notifications when we update the status of a terminal order. For more information about how to subscribe to events, go to [Events Subscriptions](https://docs.payroc.com/guides/board-merchants/event-subscriptions).

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        order_items : typing.Sequence[OrderItem]
            Array of order items. Provide a minimum of 1 order item and a maximum of 10 order items.

        training_provider : typing.Optional[TrainingProvider]

        shipping : typing.Optional[CreateTerminalOrderShipping]
            Object that contains the shipping details for the terminal order. If you don't provide a shipping address, we use the Doing Business As (DBA) address of the processing account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TerminalOrder]
            Successful request. We created the terminal order.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/terminal-orders",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "trainingProvider": training_provider,
                "shipping": convert_and_respect_annotation_metadata(
                    object_=shipping, annotation=CreateTerminalOrderShipping, direction="write"
                ),
                "orderItems": convert_and_respect_annotation_metadata(
                    object_=order_items, annotation=typing.Sequence[OrderItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TerminalOrder,
                    parse_obj_as(
                        type_=TerminalOrder,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_processing_terminals(
        self,
        processing_account_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[ProcessingTerminal, PaginatedProcessingTerminals]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of processing terminals associated with a processing account.

        **Note:** If you want to view the details of a specific processing terminal and you have its processingTerminalId, use our [Retrieve Processing Terminal](https://docs.payroc.com/api/schema/boarding/processing-terminals/retrieve) method.

        To list the terminals for a processing account, you need its processingAccountId. If you don't have the processingAccountId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for a merchant platform and its processing accounts.

        Our gateway returns the following information for each processing terminal in the list:

        - Status indicating whether the terminal is active or inactive.
        - Configuration settings, including gateway settings and application settings.
        - Features, receipt settings, and security settings.
        - Devices that use the processing terminal's configuration.

        For each processing terminal, we also return its processingTerminalId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[ProcessingTerminal, PaginatedProcessingTerminals]
            Successful request. Returns a list of processing terminals associated with the processing account.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/processing-terminals",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedProcessingTerminals,
                    parse_obj_as(
                        type_=PaginatedProcessingTerminals,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawProcessingAccountsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def retrieve(
        self, processing_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ProcessingAccount]:
        """
        Use this method to retrieve information about a specific processing account.

        To retrieve a processing account, you need its processingAccountId. Our gateway returned the processingAccountId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method or the [Create Processing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        **Note:** If you don't have the processingAccountId, use our [List Merchant Platform's Processing Accounts](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list-processing-accounts) method to search for the processing account.

        Our gateway returns the following information about the processing account:

        -    Business information, including the Merchant Category Code (MCC), status of the processing account, and address of the business.
        -    Processing information, including the merchant’s refund policies and card types that the merchant accepts.
        -    Funding information, including funding schedules, funding fees, and details for the merchant’s funding accounts.
        -    Pricing information, including [HATEOAS](https://docs.payroc.com/knowledge/basic-concepts/hypermedia-as-the-engine-of-application-state-hateoas) links to retrieve the pricing program for the processing account.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ProcessingAccount]
            Successful request. Returns the processing account.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProcessingAccount,
                    parse_obj_as(
                        type_=ProcessingAccount,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_processing_account_funding_accounts(
        self, processing_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[FundingAccount]]:
        """
        Use this method to return a list of funding accounts linked to a processing acccount.

        To retrieve a list of funding accounts for a processing account, you need the processingAccountId. Our gateway returned the processingAccountId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method or the [Create Proccessing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        Our gateway returns information about the following for each funding account in the list:
        - Account information, including the name on the account and payment methods.
        - Status, including whether we have approved or rejected the account.

        For each funding account, we also return its fundingAccountId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[FundingAccount]]
            Successful request. Returns a list of funding accounts associated with the processing account.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/funding-accounts",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[FundingAccount],
                    parse_obj_as(
                        type_=typing.List[FundingAccount],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_contacts(
        self,
        processing_account_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaginatedContacts]:
        """
        Use this method to return a list of contacts for a processing account.

        **Note:** If you want to view the details of a specific contact and you have their contactId, use our [Retrieve Contact](https://docs.payroc.com/api/schema/boarding/contacts/retrieve) method.

        To list contacts for a processing account, you need the processingAccountId. Our gateway returned the processingAccountId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method or the [Create Processing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        Our gateway returns the following information about each contact:

        - Name and contact method, including their phone number or mobile number.
        - Role within the business, for example, if they are a manager.

        For each contact, we also return a contactId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaginatedContacts]
            Successful request. Returns a list of contacts associated with the processing account.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/contacts",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedContacts,
                    parse_obj_as(
                        type_=PaginatedContacts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_processing_account_pricing_agreement(
        self, processing_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetProcessingAccountPricingAgreementProcessingAccountsResponse]:
        """
        Use this method to retrieve the pricing agreement that we apply to a processing account.

        To retrieve the pricing agreement of a processing account, you need the processingAccountId. Our gateway returned the processingAccountId in the response to the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method and [Create Processing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        **Note:** If you don't have the processingAccountId, use our [List Merchant Platform’s Processing Accounts](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list-processing-accounts) method to search for the processing account.

        Our gateway returns the following information about the pricing agreement that we apply to the processing account:

        - Base fees, including the annual fee and the fees for each chargeback and retrieval.
        - Processor fees, including the fees that we apply for processing card and ACH payments.
        - Gateway fees, including the setup fee and the fees for each transaction.
        - Service fees, including the fee that we apply if the merchant has signed up to a Hardware Advantage Plan.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetProcessingAccountPricingAgreementProcessingAccountsResponse]
            Successful request. We return a polymorphic object that contains the pricing agreement for the processing account.

            The value of the version field determines which variant you should use:
            -    `4.0` - Pricing agreement version 4.
            -    `5.0` - Pricing agreement version 5.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/pricing",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProcessingAccountPricingAgreementProcessingAccountsResponse,
                    parse_obj_as(
                        type_=GetProcessingAccountPricingAgreementProcessingAccountsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_owners(
        self,
        processing_account_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[Owner, PaginatedOwners]:
        """
        Use this method to return a list of owners of a processing account.

        **Note:** If you want to view the details of a specific owner and you have the ownerId, go to our [Retrieve Owner](https://docs.payroc.com/api/schema/boarding/owners/retrieve) method.

        To list the owners of a processing account, you need its processingAccountId. If you don't have the processingAccountId, use our [List Merchant Platform's Processing Accounts](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list-processing-accounts) method to search for the processing account.

        Our gateway returns the following information about each owner in the list:

        - Name, date of birth, and address.
        - Contact details, including their email address.
        - Relationship to the business, including whether they are a control prong or authorized signatory, and their equity stake in the business.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[Owner, PaginatedOwners]
            Successful request. Returns a list of owners associated with the processing account.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/owners",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedOwners,
                    parse_obj_as(
                        type_=PaginatedOwners,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_reminder(
        self,
        processing_account_id: str,
        *,
        idempotency_key: str,
        request: CreateReminderProcessingAccountsRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateReminderProcessingAccountsResponse]:
        """
        Use this method to prompt a merchant to sign their pricing agreement.

        You can create a reminder only if you requested the merchant’s signature by email when you created the processing account for the merchant.

        To create a reminder, you need the processingAccountId. Our gateway returned the processingAccountId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method or [Create Processing Account](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create-processing-account) method.

        **Note:** If you don’t know the processingAccountId, use our [List Merchant Platform’s Processing Accounts](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list-processing-accounts) method to search for the processing account.

        When you send a successful request, we send an email to the merchant that prompts them to sign their pricing agreement.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : CreateReminderProcessingAccountsRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateReminderProcessingAccountsResponse]
            Successful request. We sent an email to the merchant and we return a polymorphic object that contains reminder details.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/reminders",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=CreateReminderProcessingAccountsRequestBody, direction="write"
            ),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateReminderProcessingAccountsResponse,
                    parse_obj_as(
                        type_=CreateReminderProcessingAccountsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_terminal_orders(
        self,
        processing_account_id: str,
        *,
        status: typing.Optional[ListTerminalOrdersProcessingAccountsRequestStatus] = None,
        from_date_time: typing.Optional[dt.datetime] = None,
        to_date_time: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[TerminalOrder]]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of terminal orders associated with a processing account.

        **Note:** If you want to view the details of a specific terminal order and you have its terminalOrderId, use our [Retrieve Terminal Order](https://docs.payroc.com/api/schema/boarding/terminal-orders/retrieve) method.

        Use the query parameters to filter the list of results that we return, for example, to search for terminal orders by their status.

        To list the terminal orders for a processing account, you need its processingAccountId. If you don't have the processingAccountId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for a merchant platform and its processing accounts.

        Our gateway returns the following information for each terminal order in the list:

        - Status of the order
        - Items in the order
        - Training provider
        - Shipping information

        For each terminal order, we also return its terminalOrderId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        status : typing.Optional[ListTerminalOrdersProcessingAccountsRequestStatus]

        from_date_time : typing.Optional[dt.datetime]

        to_date_time : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[TerminalOrder]]
            Successful request. Returns a list of terminal orders associated with the processing account.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/terminal-orders",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "status": status,
                "fromDateTime": serialize_datetime(from_date_time) if from_date_time is not None else None,
                "toDateTime": serialize_datetime(to_date_time) if to_date_time is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TerminalOrder],
                    parse_obj_as(
                        type_=typing.List[TerminalOrder],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_terminal_order(
        self,
        processing_account_id: str,
        *,
        idempotency_key: str,
        order_items: typing.Sequence[OrderItem],
        training_provider: typing.Optional[TrainingProvider] = OMIT,
        shipping: typing.Optional[CreateTerminalOrderShipping] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TerminalOrder]:
        """
        Use this method to order and configure terminals for a processing account.

        **Note**: You need the ID of the processing account before you can create an order. If you don't know the processingAccountId, go to the [Retrieve a Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/retrieve) method.

        In the request, specify the gateway settings, device settings, and application settings for the terminal.

        In the response, our gateway returns information about the terminal order including its status and terminalOrderId that you can use to [retrieve the terminal order](https://docs.payroc.com/api/schema/boarding/terminal-orders/retrieve).

        **Note**: You can subscribe to the terminalOrder.status.changed event to get notifications when we update the status of a terminal order. For more information about how to subscribe to events, go to [Events Subscriptions](https://docs.payroc.com/guides/board-merchants/event-subscriptions).

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        order_items : typing.Sequence[OrderItem]
            Array of order items. Provide a minimum of 1 order item and a maximum of 10 order items.

        training_provider : typing.Optional[TrainingProvider]

        shipping : typing.Optional[CreateTerminalOrderShipping]
            Object that contains the shipping details for the terminal order. If you don't provide a shipping address, we use the Doing Business As (DBA) address of the processing account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TerminalOrder]
            Successful request. We created the terminal order.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/terminal-orders",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "trainingProvider": training_provider,
                "shipping": convert_and_respect_annotation_metadata(
                    object_=shipping, annotation=CreateTerminalOrderShipping, direction="write"
                ),
                "orderItems": convert_and_respect_annotation_metadata(
                    object_=order_items, annotation=typing.Sequence[OrderItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TerminalOrder,
                    parse_obj_as(
                        type_=TerminalOrder,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_processing_terminals(
        self,
        processing_account_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[ProcessingTerminal, PaginatedProcessingTerminals]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of processing terminals associated with a processing account.

        **Note:** If you want to view the details of a specific processing terminal and you have its processingTerminalId, use our [Retrieve Processing Terminal](https://docs.payroc.com/api/schema/boarding/processing-terminals/retrieve) method.

        To list the terminals for a processing account, you need its processingAccountId. If you don't have the processingAccountId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for a merchant platform and its processing accounts.

        Our gateway returns the following information for each processing terminal in the list:

        - Status indicating whether the terminal is active or inactive.
        - Configuration settings, including gateway settings and application settings.
        - Features, receipt settings, and security settings.
        - Devices that use the processing terminal's configuration.

        For each processing terminal, we also return its processingTerminalId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_account_id : str
            Unique identifier that we assigned to the processing account.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[ProcessingTerminal, PaginatedProcessingTerminals]
            Successful request. Returns a list of processing terminals associated with the processing account.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-accounts/{jsonable_encoder(processing_account_id)}/processing-terminals",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedProcessingTerminals,
                    parse_obj_as(
                        type_=PaginatedProcessingTerminals,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
