# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.custom_pagination import AsyncPayrocPager, SyncPayrocPager
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.address import Address
from ...types.business import Business
from ...types.contact import Contact
from ...types.contact_method import ContactMethod
from ...types.create_funding import CreateFunding
from ...types.create_processing_account import CreateProcessingAccount
from ...types.create_processing_account_business_type import CreateProcessingAccountBusinessType
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_nine import FourHundredNine
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.merchant_platform import MerchantPlatform
from ...types.owner import Owner
from ...types.paginated_merchants import PaginatedMerchants
from ...types.paginated_processing_accounts import PaginatedProcessingAccounts
from ...types.pricing import Pricing
from ...types.processing import Processing
from ...types.processing_account import ProcessingAccount
from ...types.signature import Signature
from ...types.timezone import Timezone

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawMerchantPlatformsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[MerchantPlatform, PaginatedMerchants]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of merchant platforms that are linked to your ISV account.

        **Note**: If you want to view the details of a specific merchant platform and you have its merchantPlatformId, use our [Retrieve Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/retrieve) method.

        Our gateway returns the following information about each merchant platform in the list:
        - Legal information, including its legal name and address.
        - Contact information, including the email address for the business.
        - Processing  account information, including the processingAccountId and status of each processing account that's linked to the merchant platform.

        For each merchant platform, we also return its merchantPlatformId and its linked processingAccountIds, which you can use to perform follow-on actions.

        Parameters
        ----------
        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[MerchantPlatform, PaginatedMerchants]
            Successful request. Returns a list of merchant platforms associated with the ISV's account.
        """
        _response = self._client_wrapper.httpx_client.request(
            "merchant-platforms",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedMerchants,
                    parse_obj_as(
                        type_=PaginatedMerchants,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        idempotency_key: str,
        business: Business,
        processing_accounts: typing.Sequence[CreateProcessingAccount],
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[MerchantPlatform]:
        """
        Use this method to board a merchant with Payroc.

        **Note**: This method is part of our Boarding solution. To help you understand how this method works with other Boarding methods, go to [Board a Merchant](https://docs.payroc.com/guides/board-merchants/boarding).

        In the request, include the following information:
        - Legal information, including its legal name and address.
        - Contact information, including the email address for the business.
        - Processing account information, including the pricing model, owners, and contacts for the processing account.

        When you send a successful request, we review the merchant's information. After we complete our review and approve the merchant, we assign:
        - **merchantPlatformId** - Unique identifier for the merchant platform.
        - **processingAccountId** - Unique identifier for each processing account linked to the merchant platform.

        You need to keep these to perform follow-on actions, for example, you need the processingAccountId to [order terminals](https://docs.payroc.com/api/schema/boarding/processing-accounts/create-terminal-order) for the processing account.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        business : Business

        processing_accounts : typing.Sequence[CreateProcessingAccount]
            Array of processingAccounts objects.

        metadata : typing.Optional[typing.Dict[str, str]]
            Object that you can send to include custom data in the request.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[MerchantPlatform]
            Successful request. We created the merchant platform.
        """
        _response = self._client_wrapper.httpx_client.request(
            "merchant-platforms",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "business": convert_and_respect_annotation_metadata(
                    object_=business, annotation=Business, direction="write"
                ),
                "processingAccounts": convert_and_respect_annotation_metadata(
                    object_=processing_accounts, annotation=typing.Sequence[CreateProcessingAccount], direction="write"
                ),
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MerchantPlatform,
                    parse_obj_as(
                        type_=MerchantPlatform,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self, merchant_platform_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[MerchantPlatform]:
        """
        Use this method to retrieve information about a merchant platform.

        To retrieve a merchant platform, you need its merchantPlatformId. Our gateway returned the merchantPlatformId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method.

        **Note:** If you don't have the merchantPlatformId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for the merchant platform.

        Our gateway returns the following information about the merchant platform:
        -    Legal information, including its legal name and address.
        -    Contact information, including the email address for the business.
        -    Processing account information, including the processingAccountId and status of each processing account that's linked to the merchant platform.

        Parameters
        ----------
        merchant_platform_id : str
            Unique identifier of the merchant platform that we sent to you when you created the merchant platform.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[MerchantPlatform]
            Successful request. Returns the merchant platform.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"merchant-platforms/{jsonable_encoder(merchant_platform_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MerchantPlatform,
                    parse_obj_as(
                        type_=MerchantPlatform,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_processing_accounts(
        self,
        merchant_platform_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        include_closed: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[ProcessingAccount, PaginatedProcessingAccounts]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of processing accounts linked to a merchant platform.

        **Note**: If you want to view the details of a specific processing account and you have its processingAccountId, use our [Retrieve Processing Account](https://docs.payroc.com/api/schema/boarding/processing-accounts/retrieve) method.

        Use the query parameters to filter the list of results that we return, for example, to search for only closed processing accounts.

        To list the processing accounts for a merchant platform, you need its merchantPlatformId. If you don't have the merchantPlatformId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for the merchant platform.

        Our gateway returns the following information about eahc processing account in the list:
        - Business details, including its status, time zone, and address.
        - Owners' details, including their contact details.
        - Funding, pricing, and processing information, including its pricing model and funding accounts.

        For each processing account, we also return its processingAccountId, which you can use to perform follow-on actions.

        Parameters
        ----------
        merchant_platform_id : str
            Unique identifier of the merchant platform that we sent to you when you created the merchant platform.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        include_closed : typing.Optional[bool]
            Indicates if you want to return closed processing accounts. This includes processing accounts that have a status of `terminated`, `cancelled`, or `rejected`.
            **Note**: By default, we return only open processing accounts.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[ProcessingAccount, PaginatedProcessingAccounts]
            Successful request. Returns a list of processing accounts associated with the merchant platform.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"merchant-platforms/{jsonable_encoder(merchant_platform_id)}/processing-accounts",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
                "includeClosed": include_closed,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedProcessingAccounts,
                    parse_obj_as(
                        type_=PaginatedProcessingAccounts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_processing_account(
        self,
        merchant_platform_id: str,
        *,
        idempotency_key: str,
        doing_business_as: str,
        owners: typing.Sequence[Owner],
        business_type: CreateProcessingAccountBusinessType,
        category_code: int,
        merchandise_or_service_sold: str,
        business_start_date: dt.date,
        timezone: Timezone,
        address: Address,
        contact_methods: typing.Sequence[ContactMethod],
        processing: Processing,
        funding: CreateFunding,
        pricing: Pricing,
        signature: Signature,
        processing_account_id: typing.Optional[str] = OMIT,
        website: typing.Optional[str] = OMIT,
        contacts: typing.Optional[typing.Sequence[Contact]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ProcessingAccount]:
        """
        Use this method to add an additional processing account to a merchant platform.

        To add a processing account to a merchant platform, you need the merchantPlatformId. Our gateway returned the merchantPlatformId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method.

        **Note**: If you don't have the merchantPlatformId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for the merchant platform.

        In the request, include the following information:
        - Business details, including its business type, time zone, and address.
        - Owners' details, including their contact details.
        - Funding, pricing, and processing information, including its pricing model and funding accounts.

        When you send a successful request, we review the information about the processing account. After we complete our review and approve the processing account, we assign a processingAccountId, which you need to perform follow-on actions.

        **Note**: You can subscribe to our processingAccount.status.changed event to get notifications when we update the status of a processing account. For more information about how to subscribe to events, go to [Events List](https://docs.payroc.com/knowledge/events/events-list).

        Parameters
        ----------
        merchant_platform_id : str
            Unique identifier of the merchant platform that we sent to you when you created the merchant platform.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        doing_business_as : str
            Trading name of the business.

        owners : typing.Sequence[Owner]
            Collection of individuals that are responsible for a processing account. When you create a processing account, you must indicate at least one owner as either of the following:

            - **Control prong** - An individual who has a significant equity stake in the business and can make decisions for the processing account. You can add only one control prong to a processing account.
            - **Authorized signatory** - An individual who doesn't have an equity stake in the business but can make decisions for the processing account.

        business_type : CreateProcessingAccountBusinessType
            Type of business.

        category_code : int
            Merchant Category Code (MCC) for the type of business.

        merchandise_or_service_sold : str
            Description of the services or merchandise sold by the business.

        business_start_date : dt.date
            Date that the business was established. The format of the value is **YYYY-MM-DD**.

        timezone : Timezone

        address : Address
            Polymorphic object that contains address information for the processing account.

        contact_methods : typing.Sequence[ContactMethod]
            Array of polymorphic objects, which contain contact information.

            **Note:** You must provide an email address.

            The value of the type parameter determines which variant you should use:
            -    `email` - Email address
            -    `phone` - Phone number
            -    `mobile` - Mobile number
            -    `fax` - Fax number.

        processing : Processing

        funding : CreateFunding

        pricing : Pricing

        signature : Signature

        processing_account_id : typing.Optional[str]
            Unique identifier of the processing account.

        website : typing.Optional[str]
            Website address of the business.

        contacts : typing.Optional[typing.Sequence[Contact]]
            Array of contact objects.

        metadata : typing.Optional[typing.Dict[str, str]]
            Object that you can send to include custom data in the request. For more information about how to use metadata, go to [Metadata](https://docs.payroc.com/api/metadata).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ProcessingAccount]
            Successful request. We created the processing account.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"merchant-platforms/{jsonable_encoder(merchant_platform_id)}/processing-accounts",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingAccountId": processing_account_id,
                "doingBusinessAs": doing_business_as,
                "owners": convert_and_respect_annotation_metadata(
                    object_=owners, annotation=typing.Sequence[Owner], direction="write"
                ),
                "website": website,
                "businessType": business_type,
                "categoryCode": category_code,
                "merchandiseOrServiceSold": merchandise_or_service_sold,
                "businessStartDate": business_start_date,
                "timezone": timezone,
                "address": convert_and_respect_annotation_metadata(
                    object_=address, annotation=Address, direction="write"
                ),
                "contactMethods": convert_and_respect_annotation_metadata(
                    object_=contact_methods, annotation=typing.Sequence[ContactMethod], direction="write"
                ),
                "processing": convert_and_respect_annotation_metadata(
                    object_=processing, annotation=Processing, direction="write"
                ),
                "funding": convert_and_respect_annotation_metadata(
                    object_=funding, annotation=CreateFunding, direction="write"
                ),
                "pricing": convert_and_respect_annotation_metadata(
                    object_=pricing, annotation=Pricing, direction="write"
                ),
                "signature": convert_and_respect_annotation_metadata(
                    object_=signature, annotation=Signature, direction="write"
                ),
                "contacts": convert_and_respect_annotation_metadata(
                    object_=contacts, annotation=typing.Sequence[Contact], direction="write"
                ),
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProcessingAccount,
                    parse_obj_as(
                        type_=ProcessingAccount,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawMerchantPlatformsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[MerchantPlatform, PaginatedMerchants]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of merchant platforms that are linked to your ISV account.

        **Note**: If you want to view the details of a specific merchant platform and you have its merchantPlatformId, use our [Retrieve Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/retrieve) method.

        Our gateway returns the following information about each merchant platform in the list:
        - Legal information, including its legal name and address.
        - Contact information, including the email address for the business.
        - Processing  account information, including the processingAccountId and status of each processing account that's linked to the merchant platform.

        For each merchant platform, we also return its merchantPlatformId and its linked processingAccountIds, which you can use to perform follow-on actions.

        Parameters
        ----------
        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[MerchantPlatform, PaginatedMerchants]
            Successful request. Returns a list of merchant platforms associated with the ISV's account.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "merchant-platforms",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedMerchants,
                    parse_obj_as(
                        type_=PaginatedMerchants,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        idempotency_key: str,
        business: Business,
        processing_accounts: typing.Sequence[CreateProcessingAccount],
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[MerchantPlatform]:
        """
        Use this method to board a merchant with Payroc.

        **Note**: This method is part of our Boarding solution. To help you understand how this method works with other Boarding methods, go to [Board a Merchant](https://docs.payroc.com/guides/board-merchants/boarding).

        In the request, include the following information:
        - Legal information, including its legal name and address.
        - Contact information, including the email address for the business.
        - Processing account information, including the pricing model, owners, and contacts for the processing account.

        When you send a successful request, we review the merchant's information. After we complete our review and approve the merchant, we assign:
        - **merchantPlatformId** - Unique identifier for the merchant platform.
        - **processingAccountId** - Unique identifier for each processing account linked to the merchant platform.

        You need to keep these to perform follow-on actions, for example, you need the processingAccountId to [order terminals](https://docs.payroc.com/api/schema/boarding/processing-accounts/create-terminal-order) for the processing account.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        business : Business

        processing_accounts : typing.Sequence[CreateProcessingAccount]
            Array of processingAccounts objects.

        metadata : typing.Optional[typing.Dict[str, str]]
            Object that you can send to include custom data in the request.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[MerchantPlatform]
            Successful request. We created the merchant platform.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "merchant-platforms",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "business": convert_and_respect_annotation_metadata(
                    object_=business, annotation=Business, direction="write"
                ),
                "processingAccounts": convert_and_respect_annotation_metadata(
                    object_=processing_accounts, annotation=typing.Sequence[CreateProcessingAccount], direction="write"
                ),
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MerchantPlatform,
                    parse_obj_as(
                        type_=MerchantPlatform,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self, merchant_platform_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[MerchantPlatform]:
        """
        Use this method to retrieve information about a merchant platform.

        To retrieve a merchant platform, you need its merchantPlatformId. Our gateway returned the merchantPlatformId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method.

        **Note:** If you don't have the merchantPlatformId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for the merchant platform.

        Our gateway returns the following information about the merchant platform:
        -    Legal information, including its legal name and address.
        -    Contact information, including the email address for the business.
        -    Processing account information, including the processingAccountId and status of each processing account that's linked to the merchant platform.

        Parameters
        ----------
        merchant_platform_id : str
            Unique identifier of the merchant platform that we sent to you when you created the merchant platform.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[MerchantPlatform]
            Successful request. Returns the merchant platform.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"merchant-platforms/{jsonable_encoder(merchant_platform_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MerchantPlatform,
                    parse_obj_as(
                        type_=MerchantPlatform,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_processing_accounts(
        self,
        merchant_platform_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        include_closed: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[ProcessingAccount, PaginatedProcessingAccounts]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of processing accounts linked to a merchant platform.

        **Note**: If you want to view the details of a specific processing account and you have its processingAccountId, use our [Retrieve Processing Account](https://docs.payroc.com/api/schema/boarding/processing-accounts/retrieve) method.

        Use the query parameters to filter the list of results that we return, for example, to search for only closed processing accounts.

        To list the processing accounts for a merchant platform, you need its merchantPlatformId. If you don't have the merchantPlatformId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for the merchant platform.

        Our gateway returns the following information about eahc processing account in the list:
        - Business details, including its status, time zone, and address.
        - Owners' details, including their contact details.
        - Funding, pricing, and processing information, including its pricing model and funding accounts.

        For each processing account, we also return its processingAccountId, which you can use to perform follow-on actions.

        Parameters
        ----------
        merchant_platform_id : str
            Unique identifier of the merchant platform that we sent to you when you created the merchant platform.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        include_closed : typing.Optional[bool]
            Indicates if you want to return closed processing accounts. This includes processing accounts that have a status of `terminated`, `cancelled`, or `rejected`.
            **Note**: By default, we return only open processing accounts.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[ProcessingAccount, PaginatedProcessingAccounts]
            Successful request. Returns a list of processing accounts associated with the merchant platform.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"merchant-platforms/{jsonable_encoder(merchant_platform_id)}/processing-accounts",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
                "includeClosed": include_closed,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedProcessingAccounts,
                    parse_obj_as(
                        type_=PaginatedProcessingAccounts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_processing_account(
        self,
        merchant_platform_id: str,
        *,
        idempotency_key: str,
        doing_business_as: str,
        owners: typing.Sequence[Owner],
        business_type: CreateProcessingAccountBusinessType,
        category_code: int,
        merchandise_or_service_sold: str,
        business_start_date: dt.date,
        timezone: Timezone,
        address: Address,
        contact_methods: typing.Sequence[ContactMethod],
        processing: Processing,
        funding: CreateFunding,
        pricing: Pricing,
        signature: Signature,
        processing_account_id: typing.Optional[str] = OMIT,
        website: typing.Optional[str] = OMIT,
        contacts: typing.Optional[typing.Sequence[Contact]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ProcessingAccount]:
        """
        Use this method to add an additional processing account to a merchant platform.

        To add a processing account to a merchant platform, you need the merchantPlatformId. Our gateway returned the merchantPlatformId in the response of the [Create Merchant Platform](https://docs.payroc.com/api/schema/boarding/merchant-platforms/create) method.

        **Note**: If you don't have the merchantPlatformId, use our [List Merchant Platforms](https://docs.payroc.com/api/schema/boarding/merchant-platforms/list) method to search for the merchant platform.

        In the request, include the following information:
        - Business details, including its business type, time zone, and address.
        - Owners' details, including their contact details.
        - Funding, pricing, and processing information, including its pricing model and funding accounts.

        When you send a successful request, we review the information about the processing account. After we complete our review and approve the processing account, we assign a processingAccountId, which you need to perform follow-on actions.

        **Note**: You can subscribe to our processingAccount.status.changed event to get notifications when we update the status of a processing account. For more information about how to subscribe to events, go to [Events List](https://docs.payroc.com/knowledge/events/events-list).

        Parameters
        ----------
        merchant_platform_id : str
            Unique identifier of the merchant platform that we sent to you when you created the merchant platform.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        doing_business_as : str
            Trading name of the business.

        owners : typing.Sequence[Owner]
            Collection of individuals that are responsible for a processing account. When you create a processing account, you must indicate at least one owner as either of the following:

            - **Control prong** - An individual who has a significant equity stake in the business and can make decisions for the processing account. You can add only one control prong to a processing account.
            - **Authorized signatory** - An individual who doesn't have an equity stake in the business but can make decisions for the processing account.

        business_type : CreateProcessingAccountBusinessType
            Type of business.

        category_code : int
            Merchant Category Code (MCC) for the type of business.

        merchandise_or_service_sold : str
            Description of the services or merchandise sold by the business.

        business_start_date : dt.date
            Date that the business was established. The format of the value is **YYYY-MM-DD**.

        timezone : Timezone

        address : Address
            Polymorphic object that contains address information for the processing account.

        contact_methods : typing.Sequence[ContactMethod]
            Array of polymorphic objects, which contain contact information.

            **Note:** You must provide an email address.

            The value of the type parameter determines which variant you should use:
            -    `email` - Email address
            -    `phone` - Phone number
            -    `mobile` - Mobile number
            -    `fax` - Fax number.

        processing : Processing

        funding : CreateFunding

        pricing : Pricing

        signature : Signature

        processing_account_id : typing.Optional[str]
            Unique identifier of the processing account.

        website : typing.Optional[str]
            Website address of the business.

        contacts : typing.Optional[typing.Sequence[Contact]]
            Array of contact objects.

        metadata : typing.Optional[typing.Dict[str, str]]
            Object that you can send to include custom data in the request. For more information about how to use metadata, go to [Metadata](https://docs.payroc.com/api/metadata).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ProcessingAccount]
            Successful request. We created the processing account.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"merchant-platforms/{jsonable_encoder(merchant_platform_id)}/processing-accounts",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingAccountId": processing_account_id,
                "doingBusinessAs": doing_business_as,
                "owners": convert_and_respect_annotation_metadata(
                    object_=owners, annotation=typing.Sequence[Owner], direction="write"
                ),
                "website": website,
                "businessType": business_type,
                "categoryCode": category_code,
                "merchandiseOrServiceSold": merchandise_or_service_sold,
                "businessStartDate": business_start_date,
                "timezone": timezone,
                "address": convert_and_respect_annotation_metadata(
                    object_=address, annotation=Address, direction="write"
                ),
                "contactMethods": convert_and_respect_annotation_metadata(
                    object_=contact_methods, annotation=typing.Sequence[ContactMethod], direction="write"
                ),
                "processing": convert_and_respect_annotation_metadata(
                    object_=processing, annotation=Processing, direction="write"
                ),
                "funding": convert_and_respect_annotation_metadata(
                    object_=funding, annotation=CreateFunding, direction="write"
                ),
                "pricing": convert_and_respect_annotation_metadata(
                    object_=pricing, annotation=Pricing, direction="write"
                ),
                "signature": convert_and_respect_annotation_metadata(
                    object_=signature, annotation=Signature, direction="write"
                ),
                "contacts": convert_and_respect_annotation_metadata(
                    object_=contacts, annotation=typing.Sequence[Contact], direction="write"
                ),
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProcessingAccount,
                    parse_obj_as(
                        type_=ProcessingAccount,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
