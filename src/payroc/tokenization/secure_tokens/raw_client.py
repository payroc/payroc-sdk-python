# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.custom_pagination import AsyncPayrocPager, SyncPayrocPager
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.content_too_large_error import ContentTooLargeError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ...types.account_update import AccountUpdate
from ...types.custom_field import CustomField
from ...types.customer import Customer
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_fifteen import FourHundredFifteen
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_nine import FourHundredNine
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.four_hundred_thirteen import FourHundredThirteen
from ...types.ip_address import IpAddress
from ...types.patch_request import PatchRequest
from ...types.secure_token import SecureToken
from ...types.secure_token_paginated_list_with_account_type import SecureTokenPaginatedListWithAccountType
from ...types.secure_token_with_account_type import SecureTokenWithAccountType
from .types.tokenization_request_mit_agreement import TokenizationRequestMitAgreement
from .types.tokenization_request_source import TokenizationRequestSource
from .types.tokenization_request_three_d_secure import TokenizationRequestThreeDSecure

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawSecureTokensClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        processing_terminal_id: str,
        *,
        secure_token_id: typing.Optional[str] = None,
        customer_name: typing.Optional[str] = None,
        phone: typing.Optional[str] = None,
        email: typing.Optional[str] = None,
        token: typing.Optional[str] = None,
        first_6: typing.Optional[str] = None,
        last_4: typing.Optional[str] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[SecureTokenWithAccountType, SecureTokenPaginatedListWithAccountType]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of secure tokens.

        **Note:** If you want to view the details of a specific secure token and you have its secureTokenId, use our [Retrieve Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/retrieve) method.

        Use query parameters to filter the list of results that we return, for example, to search for secure tokens by customer or by the first four digits of a card number.

        Our gateway returns information about the following for each secure token in the list:

          -    Payment details that the secure token represents.
          -    Customer details, including shipping and billing addresses.
          -    Secure token that you can use to carry out transactions.

          For each secure token, we also return the secureTokenId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : typing.Optional[str]
            Unique identifier that the merchant assigned to the secure token.

        customer_name : typing.Optional[str]
            Filter by the customer's name.

        phone : typing.Optional[str]
            Filter by the customer's phone number.

        email : typing.Optional[str]
            Filter by the customer's email address.

        token : typing.Optional[str]
            Filter by the token that the merchant used in a transaction to represent the customer's payment details.

        first_6 : typing.Optional[str]
            Filter by the first six digits of the card number.

        last_4 : typing.Optional[str]
            Filter by the last four digits of the card or account number.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[SecureTokenWithAccountType, SecureTokenPaginatedListWithAccountType]
            Successful request. Returns a list of secure tokens that are currently saved on the terminal.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "secureTokenId": secure_token_id,
                "customerName": customer_name,
                "phone": phone,
                "email": email,
                "token": token,
                "first6": first_6,
                "last4": last_4,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    SecureTokenPaginatedListWithAccountType,
                    parse_obj_as(
                        type_=SecureTokenPaginatedListWithAccountType,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        processing_terminal_id: str,
        *,
        idempotency_key: str,
        source: TokenizationRequestSource,
        secure_token_id: typing.Optional[str] = OMIT,
        operator: typing.Optional[str] = OMIT,
        mit_agreement: typing.Optional[TokenizationRequestMitAgreement] = OMIT,
        customer: typing.Optional[Customer] = OMIT,
        ip_address: typing.Optional[IpAddress] = OMIT,
        three_d_secure: typing.Optional[TokenizationRequestThreeDSecure] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SecureToken]:
        """
        Use this method to create a secure token that represents a customer's payment details.

        When you create a secure token, you need to generate and provide a secureTokenId that you use to run follow-on actions:
        - [Retrieve Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/retrieve) – View the details of the secure token.
        - [Delete Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/delete) – Delete the secure token.
        - [Update Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/partially-update) – Update the details of the secure token.
        - [Update Account Details](https://docs.payroc.com/api/schema/tokenization/secure-tokens/update-account) – Update the secure token with the details from a single-use token.

        **Note:** If you don't generate a secureTokenId to identify the token, our gateway generates a unique identifier and returns it in the response.

        If the request is successful, our gateway returns a token that the merchant can use in transactions instead of the customer's sensitive payment details, for example, when they [run a sale](https://docs.payroc.com/api/schema/card-payments/payments/create).

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        source : TokenizationRequestSource
            Polymorphic object that contains the payment method to tokenize.

            The value of the type parameter determines which variant you should use:
            -    `ach` - Automated Clearing House (ACH) details
            -    `pad` - Pre-authorized debit (PAD) details
            -    `card` - Payment card details
            -    `singleUseToken` - Single-use token details

        secure_token_id : typing.Optional[str]
            Unique identifier that the merchant created for the secure token that represents the customer's payment details.
            If the merchant doesn't create a secureTokenId, the gateway generates one and returns it in the response.

        operator : typing.Optional[str]
            Operator who saved the customer's payment details.

        mit_agreement : typing.Optional[TokenizationRequestMitAgreement]
            Indicates how the merchant can use the customer's card details, as agreed by the customer:

            - `unscheduled` - Transactions for a fixed or variable amount that are run at a certain pre-defined event.
            - `recurring` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Recurring transactions don't have a fixed duration and run until the customer cancels the agreement.
            - `installment` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Installment transactions have a fixed duration.

        customer : typing.Optional[Customer]

        ip_address : typing.Optional[IpAddress]

        three_d_secure : typing.Optional[TokenizationRequestThreeDSecure]
            Polymorphic object that contains authentication information from 3-D Secure.

            The value of the type parameter determines which variant you should use:
            -    `gatewayThreeDSecure` - Use our gateway to run a 3-D Secure check.
            -    `thirdPartyThreeDSecure` - Use a third party to run a 3-D Secure check.

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SecureToken]
            Successful request. We created a secure token that represents your customer's payment details.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "secureTokenId": secure_token_id,
                "operator": operator,
                "mitAgreement": mit_agreement,
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=Customer, direction="write"
                ),
                "ipAddress": convert_and_respect_annotation_metadata(
                    object_=ip_address, annotation=IpAddress, direction="write"
                ),
                "source": convert_and_respect_annotation_metadata(
                    object_=source, annotation=TokenizationRequestSource, direction="write"
                ),
                "threeDSecure": convert_and_respect_annotation_metadata(
                    object_=three_d_secure, annotation=TokenizationRequestThreeDSecure, direction="write"
                ),
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SecureToken,
                    parse_obj_as(
                        type_=SecureToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self,
        processing_terminal_id: str,
        secure_token_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SecureTokenWithAccountType]:
        """
        Use this method to retrieve information about a secure token.

        To retrieve a secure token, you need its secureTokenID, which you sent in the request of the [Create Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/create) method.

        **Note:** If you don't have the secureTokenId, use our [List Secure Tokens](https://docs.payroc.com/api/schema/tokenization/secure-tokens/list) method to search for the secure token.

        Our gateway returns the following information about the secure token:

          -    Payment details that the secure token represents.
          -    Customer details, including shipping and billing addresses.
          -    Secure token that you can use to carry out transactions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : str
            Unique identifier that the merchant assigned to the secure token.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SecureTokenWithAccountType]
            Successful request. Returns the secure token and its related payment details.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens/{jsonable_encoder(secure_token_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SecureTokenWithAccountType,
                    parse_obj_as(
                        type_=SecureTokenWithAccountType,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        processing_terminal_id: str,
        secure_token_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Use this method to delete a secure token and its related payment details from our vault.

        To delete a secure token, you need its secureTokenId, which you sent in the request of the [Create Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/create) method.

        **Note:** If you don’t have the secureTokenId, use our [List Secure Tokens](https://docs.payroc.com/api/schema/tokenization/secure-tokens/list) method to search for the secure token.

        When you delete a secure token, you can’t recover it, and you can’t reuse its identifier for a new token.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : str
            Unique identifier that the merchant assigned to the secure token.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens/{jsonable_encoder(secure_token_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def partially_update(
        self,
        processing_terminal_id: str,
        secure_token_id: str,
        *,
        idempotency_key: str,
        request: PatchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SecureToken]:
        """
        Use this method to partially update a secure token. Structure your request to follow the [RFC 6902](https://datatracker.ietf.org/doc/html/rfc6902) standard.

        To update a secure token, you need its secureTokenId, which you sent in the request of the [Create Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/create) method.

        **Note:** If you don't have the secureTokenId, use our [List Secure Tokens](https://docs.payroc.com/api/schema/tokenization/secure-tokens/list) method to search  for the payment.

        You can update all of the properties of the secure token, except the following:
        - processingTerminalId
        - type
        - token
        - status
        - source/Card
          - type
          - cardNumber
          - cardType
          - currency
          - debit
          - surcharging
        - source/ACH account
          - accountNumber
          - routingNumber
        - source/PAD account
          - type
          - accountNumber
          - transitNumber

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : str
            Unique identifier that the merchant assigned to the secure token.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : PatchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SecureToken]
            Successful request. We updated the customer's payment details.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens/{jsonable_encoder(secure_token_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PATCH",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=PatchRequest, direction="write"),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SecureToken,
                    parse_obj_as(
                        type_=SecureToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_account(
        self,
        processing_terminal_id: str,
        secure_token_id: str,
        *,
        idempotency_key: str,
        request: AccountUpdate,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SecureToken]:
        """
        Use this method to update a secure token if you have a single-use token from Hosted Fields.

        **Note:** If you don't have a single-use token, you can update saved payment details with our [Update Secure Token](https://docs.payroc.com/api/resources#updateSecureToken) method. For more information about our two options to update a secure token, go to [Update saved payment details](https://docs.payroc.com/guides/take-payments/update-saved-payment-details).

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : str
            Unique identifier that the merchant assigned to the secure token.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : AccountUpdate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SecureToken]
            Successful request. We updated the payment details represented by the secure token.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens/{jsonable_encoder(secure_token_id)}/update-account",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=AccountUpdate, direction="write"),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SecureToken,
                    parse_obj_as(
                        type_=SecureToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredThirteen,
                        parse_obj_as(
                            type_=FourHundredThirteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawSecureTokensClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        processing_terminal_id: str,
        *,
        secure_token_id: typing.Optional[str] = None,
        customer_name: typing.Optional[str] = None,
        phone: typing.Optional[str] = None,
        email: typing.Optional[str] = None,
        token: typing.Optional[str] = None,
        first_6: typing.Optional[str] = None,
        last_4: typing.Optional[str] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[SecureTokenWithAccountType, SecureTokenPaginatedListWithAccountType]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of secure tokens.

        **Note:** If you want to view the details of a specific secure token and you have its secureTokenId, use our [Retrieve Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/retrieve) method.

        Use query parameters to filter the list of results that we return, for example, to search for secure tokens by customer or by the first four digits of a card number.

        Our gateway returns information about the following for each secure token in the list:

          -    Payment details that the secure token represents.
          -    Customer details, including shipping and billing addresses.
          -    Secure token that you can use to carry out transactions.

          For each secure token, we also return the secureTokenId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : typing.Optional[str]
            Unique identifier that the merchant assigned to the secure token.

        customer_name : typing.Optional[str]
            Filter by the customer's name.

        phone : typing.Optional[str]
            Filter by the customer's phone number.

        email : typing.Optional[str]
            Filter by the customer's email address.

        token : typing.Optional[str]
            Filter by the token that the merchant used in a transaction to represent the customer's payment details.

        first_6 : typing.Optional[str]
            Filter by the first six digits of the card number.

        last_4 : typing.Optional[str]
            Filter by the last four digits of the card or account number.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[SecureTokenWithAccountType, SecureTokenPaginatedListWithAccountType]
            Successful request. Returns a list of secure tokens that are currently saved on the terminal.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "secureTokenId": secure_token_id,
                "customerName": customer_name,
                "phone": phone,
                "email": email,
                "token": token,
                "first6": first_6,
                "last4": last_4,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    SecureTokenPaginatedListWithAccountType,
                    parse_obj_as(
                        type_=SecureTokenPaginatedListWithAccountType,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        processing_terminal_id: str,
        *,
        idempotency_key: str,
        source: TokenizationRequestSource,
        secure_token_id: typing.Optional[str] = OMIT,
        operator: typing.Optional[str] = OMIT,
        mit_agreement: typing.Optional[TokenizationRequestMitAgreement] = OMIT,
        customer: typing.Optional[Customer] = OMIT,
        ip_address: typing.Optional[IpAddress] = OMIT,
        three_d_secure: typing.Optional[TokenizationRequestThreeDSecure] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SecureToken]:
        """
        Use this method to create a secure token that represents a customer's payment details.

        When you create a secure token, you need to generate and provide a secureTokenId that you use to run follow-on actions:
        - [Retrieve Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/retrieve) – View the details of the secure token.
        - [Delete Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/delete) – Delete the secure token.
        - [Update Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/partially-update) – Update the details of the secure token.
        - [Update Account Details](https://docs.payroc.com/api/schema/tokenization/secure-tokens/update-account) – Update the secure token with the details from a single-use token.

        **Note:** If you don't generate a secureTokenId to identify the token, our gateway generates a unique identifier and returns it in the response.

        If the request is successful, our gateway returns a token that the merchant can use in transactions instead of the customer's sensitive payment details, for example, when they [run a sale](https://docs.payroc.com/api/schema/card-payments/payments/create).

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        source : TokenizationRequestSource
            Polymorphic object that contains the payment method to tokenize.

            The value of the type parameter determines which variant you should use:
            -    `ach` - Automated Clearing House (ACH) details
            -    `pad` - Pre-authorized debit (PAD) details
            -    `card` - Payment card details
            -    `singleUseToken` - Single-use token details

        secure_token_id : typing.Optional[str]
            Unique identifier that the merchant created for the secure token that represents the customer's payment details.
            If the merchant doesn't create a secureTokenId, the gateway generates one and returns it in the response.

        operator : typing.Optional[str]
            Operator who saved the customer's payment details.

        mit_agreement : typing.Optional[TokenizationRequestMitAgreement]
            Indicates how the merchant can use the customer's card details, as agreed by the customer:

            - `unscheduled` - Transactions for a fixed or variable amount that are run at a certain pre-defined event.
            - `recurring` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Recurring transactions don't have a fixed duration and run until the customer cancels the agreement.
            - `installment` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Installment transactions have a fixed duration.

        customer : typing.Optional[Customer]

        ip_address : typing.Optional[IpAddress]

        three_d_secure : typing.Optional[TokenizationRequestThreeDSecure]
            Polymorphic object that contains authentication information from 3-D Secure.

            The value of the type parameter determines which variant you should use:
            -    `gatewayThreeDSecure` - Use our gateway to run a 3-D Secure check.
            -    `thirdPartyThreeDSecure` - Use a third party to run a 3-D Secure check.

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SecureToken]
            Successful request. We created a secure token that represents your customer's payment details.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "secureTokenId": secure_token_id,
                "operator": operator,
                "mitAgreement": mit_agreement,
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=Customer, direction="write"
                ),
                "ipAddress": convert_and_respect_annotation_metadata(
                    object_=ip_address, annotation=IpAddress, direction="write"
                ),
                "source": convert_and_respect_annotation_metadata(
                    object_=source, annotation=TokenizationRequestSource, direction="write"
                ),
                "threeDSecure": convert_and_respect_annotation_metadata(
                    object_=three_d_secure, annotation=TokenizationRequestThreeDSecure, direction="write"
                ),
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SecureToken,
                    parse_obj_as(
                        type_=SecureToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self,
        processing_terminal_id: str,
        secure_token_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SecureTokenWithAccountType]:
        """
        Use this method to retrieve information about a secure token.

        To retrieve a secure token, you need its secureTokenID, which you sent in the request of the [Create Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/create) method.

        **Note:** If you don't have the secureTokenId, use our [List Secure Tokens](https://docs.payroc.com/api/schema/tokenization/secure-tokens/list) method to search for the secure token.

        Our gateway returns the following information about the secure token:

          -    Payment details that the secure token represents.
          -    Customer details, including shipping and billing addresses.
          -    Secure token that you can use to carry out transactions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : str
            Unique identifier that the merchant assigned to the secure token.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SecureTokenWithAccountType]
            Successful request. Returns the secure token and its related payment details.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens/{jsonable_encoder(secure_token_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SecureTokenWithAccountType,
                    parse_obj_as(
                        type_=SecureTokenWithAccountType,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        processing_terminal_id: str,
        secure_token_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Use this method to delete a secure token and its related payment details from our vault.

        To delete a secure token, you need its secureTokenId, which you sent in the request of the [Create Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/create) method.

        **Note:** If you don’t have the secureTokenId, use our [List Secure Tokens](https://docs.payroc.com/api/schema/tokenization/secure-tokens/list) method to search for the secure token.

        When you delete a secure token, you can’t recover it, and you can’t reuse its identifier for a new token.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : str
            Unique identifier that the merchant assigned to the secure token.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens/{jsonable_encoder(secure_token_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def partially_update(
        self,
        processing_terminal_id: str,
        secure_token_id: str,
        *,
        idempotency_key: str,
        request: PatchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SecureToken]:
        """
        Use this method to partially update a secure token. Structure your request to follow the [RFC 6902](https://datatracker.ietf.org/doc/html/rfc6902) standard.

        To update a secure token, you need its secureTokenId, which you sent in the request of the [Create Secure Token](https://docs.payroc.com/api/schema/tokenization/secure-tokens/create) method.

        **Note:** If you don't have the secureTokenId, use our [List Secure Tokens](https://docs.payroc.com/api/schema/tokenization/secure-tokens/list) method to search  for the payment.

        You can update all of the properties of the secure token, except the following:
        - processingTerminalId
        - type
        - token
        - status
        - source/Card
          - type
          - cardNumber
          - cardType
          - currency
          - debit
          - surcharging
        - source/ACH account
          - accountNumber
          - routingNumber
        - source/PAD account
          - type
          - accountNumber
          - transitNumber

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : str
            Unique identifier that the merchant assigned to the secure token.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : PatchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SecureToken]
            Successful request. We updated the customer's payment details.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens/{jsonable_encoder(secure_token_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PATCH",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=PatchRequest, direction="write"),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SecureToken,
                    parse_obj_as(
                        type_=SecureToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_account(
        self,
        processing_terminal_id: str,
        secure_token_id: str,
        *,
        idempotency_key: str,
        request: AccountUpdate,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SecureToken]:
        """
        Use this method to update a secure token if you have a single-use token from Hosted Fields.

        **Note:** If you don't have a single-use token, you can update saved payment details with our [Update Secure Token](https://docs.payroc.com/api/resources#updateSecureToken) method. For more information about our two options to update a secure token, go to [Update saved payment details](https://docs.payroc.com/guides/take-payments/update-saved-payment-details).

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        secure_token_id : str
            Unique identifier that the merchant assigned to the secure token.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : AccountUpdate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SecureToken]
            Successful request. We updated the payment details represented by the secure token.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/secure-tokens/{jsonable_encoder(secure_token_id)}/update-account",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=AccountUpdate, direction="write"),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SecureToken,
                    parse_obj_as(
                        type_=SecureToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredThirteen,
                        parse_obj_as(
                            type_=FourHundredThirteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
