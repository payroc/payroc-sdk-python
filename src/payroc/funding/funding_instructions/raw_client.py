# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.custom_pagination import AsyncPayrocPager, SyncPayrocPager
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_nine import FourHundredNine
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.instruction import Instruction
from ...types.instruction_merchants_item import InstructionMerchantsItem
from ...types.instruction_status import InstructionStatus
from .types.list_funding_instructions_response import ListFundingInstructionsResponse
from .types.list_funding_instructions_response_data_item import ListFundingInstructionsResponseDataItem

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawFundingInstructionsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        date_from: dt.date,
        date_to: dt.date,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[ListFundingInstructionsResponseDataItem, ListFundingInstructionsResponse]:
        """
        > Important: You can return a list of funding instructions from only the previous two years. If you want to view a funding instruction from more than two years ago and you have its instructionId, use our [Retrieve Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/retrieve) method.

        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of funding instructions within a specific date range.

        **Note:** If you want to view the details of a specific funding instruction and you have its instructionId, use our [Retrieve Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/retrieve) method.

        Our gateway returns the following information for each instruction in the list:
        -    Status of the funding instruction.
        -    Funding information, including which merchant's funding balance we distribute and the funding account that we send the balance to.

        For each funding instruction, we also return the instructionId, which you can use to perform follow-on actions.

        Parameters
        ----------
        date_from : dt.date
            Filter by funding instructions sent after a specific date. Send a value in **YYYY-MM-DD** format.

        date_to : dt.date
            Filter by funding instructions sent before a specific date. Send a value in **YYYY-MM-DD** format.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[ListFundingInstructionsResponseDataItem, ListFundingInstructionsResponse]
            Successful request. Returns a list of funding instructions.
        """
        _response = self._client_wrapper.httpx_client.request(
            "funding-instructions",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
                "dateFrom": str(date_from),
                "dateTo": str(date_to),
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListFundingInstructionsResponse,
                    parse_obj_as(
                        type_=ListFundingInstructionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        idempotency_key: str,
        instruction_id: typing.Optional[int] = OMIT,
        created_date: typing.Optional[str] = OMIT,
        last_modified_date: typing.Optional[str] = OMIT,
        status: typing.Optional[InstructionStatus] = OMIT,
        merchants: typing.Optional[typing.Sequence[InstructionMerchantsItem]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Instruction]:
        """
        Use this method to create a funding instruction that tells us how to distribute the funds from your merchants' transactions.

        **Note:** Before you create a funding instruction, you can use our [List Funding Balances](https://docs.payroc.com/api/schema/funding/funding-activity/retrieve-balance) method to view the amount of available funds that a merchant has.

        In your request, include an array of merchantInstruction objects. Each merchantInstruction object contains the following:
        -    Merchant ID (MID) of the merchant whose funding balance you want to distribute.
        -    Funding account that you want to send funds to.
        -    Amount that you want to send to the funding account.

        Our gateway returns the instructionId, which you can use to run follow-on actions.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        instruction_id : typing.Optional[int]
            Unique identifier that we assigned to the funding instruction.

        created_date : typing.Optional[str]
            Date that we created the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        last_modified_date : typing.Optional[str]
            Date of the most recent change to the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        status : typing.Optional[InstructionStatus]
            Status of the funding instruction. Our gateway returns one of the following values:
            - `accepted` - We have received the funding instruction but have not yet reviewed it.
            - `pending` - We have received the funding instruction and we are reviewing it.
            - `completed` - We have reviewed and processed the funding instruction.

        merchants : typing.Optional[typing.Sequence[InstructionMerchantsItem]]
            Array of merchants objects. Each object specifies the merchant whose funding balance we distribute and who you want to send the funds to.

        metadata : typing.Optional[typing.Dict[str, str]]
            [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Instruction]
            Successful request. We accepted the instructions.
        """
        _response = self._client_wrapper.httpx_client.request(
            "funding-instructions",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "instructionId": instruction_id,
                "createdDate": created_date,
                "lastModifiedDate": last_modified_date,
                "status": status,
                "merchants": convert_and_respect_annotation_metadata(
                    object_=merchants, annotation=typing.Sequence[InstructionMerchantsItem], direction="write"
                ),
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Instruction,
                    parse_obj_as(
                        type_=Instruction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self, instruction_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Instruction]:
        """
        Use this method to retrieve information about a funding instruction.

        To retrieve a funding instruction, you need its instructionId. Our gateway returned the instructionId in the response of the [Create Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/create) method.

        **Note:** If you don't have the instructionId, use our [List Funding Instructions](https://docs.payroc.com/api/schema/funding/funding-instructions/list) method to search for the funding instruction.

        Our gateway returns the following information about the funding instruction:
        -    Status of the funding instruction.
        -    Funding information, including which merchant's funding balance we distribute and the funding account that we send the balance to.

        Parameters
        ----------
        instruction_id : int
            Unique identifier that we assigned to the funding instruction.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Instruction]
            Successful request. Returns the funding instruction.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"funding-instructions/{jsonable_encoder(instruction_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Instruction,
                    parse_obj_as(
                        type_=Instruction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        instruction_id_: int,
        *,
        instruction_id: typing.Optional[int] = OMIT,
        created_date: typing.Optional[str] = OMIT,
        last_modified_date: typing.Optional[str] = OMIT,
        status: typing.Optional[InstructionStatus] = OMIT,
        merchants: typing.Optional[typing.Sequence[InstructionMerchantsItem]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        > **Important:** You can update a funding instruction only if its status is `accepted`. To view the status of a funding instruction, use our [Retrieve Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/retrieve) method.

        Use this method to update the details of a funding instruction.

        To update a funding instruction, you need its instructionId. Our gateway returned the instructionId in the response of the [Create Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/create) method.

        **Note:** If you don't have the fundingInstructionId, use our [List Funding Instructions](https://docs.payroc.com/api/schema/funding/funding-instructions/list) method to search for the funding instruction.

        You can modify the following information for the funding instruction:
        -    Merchant ID (MID) of the merchant whose funding balance you want to distribute.
        -    Funding account that you want to send funds to.
        -    Amount that you want to send to the funding account.

        Parameters
        ----------
        instruction_id_ : int
            Unique identifier that we assigned to the funding instruction.

        instruction_id : typing.Optional[int]
            Unique identifier that we assigned to the funding instruction.

        created_date : typing.Optional[str]
            Date that we created the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        last_modified_date : typing.Optional[str]
            Date of the most recent change to the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        status : typing.Optional[InstructionStatus]
            Status of the funding instruction. Our gateway returns one of the following values:
            - `accepted` - We have received the funding instruction but have not yet reviewed it.
            - `pending` - We have received the funding instruction and we are reviewing it.
            - `completed` - We have reviewed and processed the funding instruction.

        merchants : typing.Optional[typing.Sequence[InstructionMerchantsItem]]
            Array of merchants objects. Each object specifies the merchant whose funding balance we distribute and who you want to send the funds to.

        metadata : typing.Optional[typing.Dict[str, str]]
            [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"funding-instructions/{jsonable_encoder(instruction_id_)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PUT",
            json={
                "instructionId": instruction_id,
                "createdDate": created_date,
                "lastModifiedDate": last_modified_date,
                "status": status,
                "merchants": convert_and_respect_annotation_metadata(
                    object_=merchants, annotation=typing.Sequence[InstructionMerchantsItem], direction="write"
                ),
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self, instruction_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        > **Important:** You can delete a funding instruction only if its status is `accepted`. To view the status of a funding instruction, use our [Retrieve Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/retrieve) method.

        Use this method to delete a funding instruction.

        To delete a funding instruction, you need its instructionId. Our gateway returned the instructionId in the response of the [Create Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/create) method.

        **Note:** If you don't have the instructionId, use our [List Funding Instructions](https://docs.payroc.com/api/schema/funding/funding-instructions/list) method to search for the funding instruction.

        Parameters
        ----------
        instruction_id : int
            Unique identifier that we assigned to the funding instruction.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"funding-instructions/{jsonable_encoder(instruction_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawFundingInstructionsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        date_from: dt.date,
        date_to: dt.date,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[ListFundingInstructionsResponseDataItem, ListFundingInstructionsResponse]:
        """
        > Important: You can return a list of funding instructions from only the previous two years. If you want to view a funding instruction from more than two years ago and you have its instructionId, use our [Retrieve Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/retrieve) method.

        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of funding instructions within a specific date range.

        **Note:** If you want to view the details of a specific funding instruction and you have its instructionId, use our [Retrieve Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/retrieve) method.

        Our gateway returns the following information for each instruction in the list:
        -    Status of the funding instruction.
        -    Funding information, including which merchant's funding balance we distribute and the funding account that we send the balance to.

        For each funding instruction, we also return the instructionId, which you can use to perform follow-on actions.

        Parameters
        ----------
        date_from : dt.date
            Filter by funding instructions sent after a specific date. Send a value in **YYYY-MM-DD** format.

        date_to : dt.date
            Filter by funding instructions sent before a specific date. Send a value in **YYYY-MM-DD** format.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[ListFundingInstructionsResponseDataItem, ListFundingInstructionsResponse]
            Successful request. Returns a list of funding instructions.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "funding-instructions",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
                "dateFrom": str(date_from),
                "dateTo": str(date_to),
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListFundingInstructionsResponse,
                    parse_obj_as(
                        type_=ListFundingInstructionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        idempotency_key: str,
        instruction_id: typing.Optional[int] = OMIT,
        created_date: typing.Optional[str] = OMIT,
        last_modified_date: typing.Optional[str] = OMIT,
        status: typing.Optional[InstructionStatus] = OMIT,
        merchants: typing.Optional[typing.Sequence[InstructionMerchantsItem]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Instruction]:
        """
        Use this method to create a funding instruction that tells us how to distribute the funds from your merchants' transactions.

        **Note:** Before you create a funding instruction, you can use our [List Funding Balances](https://docs.payroc.com/api/schema/funding/funding-activity/retrieve-balance) method to view the amount of available funds that a merchant has.

        In your request, include an array of merchantInstruction objects. Each merchantInstruction object contains the following:
        -    Merchant ID (MID) of the merchant whose funding balance you want to distribute.
        -    Funding account that you want to send funds to.
        -    Amount that you want to send to the funding account.

        Our gateway returns the instructionId, which you can use to run follow-on actions.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        instruction_id : typing.Optional[int]
            Unique identifier that we assigned to the funding instruction.

        created_date : typing.Optional[str]
            Date that we created the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        last_modified_date : typing.Optional[str]
            Date of the most recent change to the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        status : typing.Optional[InstructionStatus]
            Status of the funding instruction. Our gateway returns one of the following values:
            - `accepted` - We have received the funding instruction but have not yet reviewed it.
            - `pending` - We have received the funding instruction and we are reviewing it.
            - `completed` - We have reviewed and processed the funding instruction.

        merchants : typing.Optional[typing.Sequence[InstructionMerchantsItem]]
            Array of merchants objects. Each object specifies the merchant whose funding balance we distribute and who you want to send the funds to.

        metadata : typing.Optional[typing.Dict[str, str]]
            [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Instruction]
            Successful request. We accepted the instructions.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "funding-instructions",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "instructionId": instruction_id,
                "createdDate": created_date,
                "lastModifiedDate": last_modified_date,
                "status": status,
                "merchants": convert_and_respect_annotation_metadata(
                    object_=merchants, annotation=typing.Sequence[InstructionMerchantsItem], direction="write"
                ),
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Instruction,
                    parse_obj_as(
                        type_=Instruction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self, instruction_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Instruction]:
        """
        Use this method to retrieve information about a funding instruction.

        To retrieve a funding instruction, you need its instructionId. Our gateway returned the instructionId in the response of the [Create Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/create) method.

        **Note:** If you don't have the instructionId, use our [List Funding Instructions](https://docs.payroc.com/api/schema/funding/funding-instructions/list) method to search for the funding instruction.

        Our gateway returns the following information about the funding instruction:
        -    Status of the funding instruction.
        -    Funding information, including which merchant's funding balance we distribute and the funding account that we send the balance to.

        Parameters
        ----------
        instruction_id : int
            Unique identifier that we assigned to the funding instruction.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Instruction]
            Successful request. Returns the funding instruction.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"funding-instructions/{jsonable_encoder(instruction_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Instruction,
                    parse_obj_as(
                        type_=Instruction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        instruction_id_: int,
        *,
        instruction_id: typing.Optional[int] = OMIT,
        created_date: typing.Optional[str] = OMIT,
        last_modified_date: typing.Optional[str] = OMIT,
        status: typing.Optional[InstructionStatus] = OMIT,
        merchants: typing.Optional[typing.Sequence[InstructionMerchantsItem]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        > **Important:** You can update a funding instruction only if its status is `accepted`. To view the status of a funding instruction, use our [Retrieve Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/retrieve) method.

        Use this method to update the details of a funding instruction.

        To update a funding instruction, you need its instructionId. Our gateway returned the instructionId in the response of the [Create Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/create) method.

        **Note:** If you don't have the fundingInstructionId, use our [List Funding Instructions](https://docs.payroc.com/api/schema/funding/funding-instructions/list) method to search for the funding instruction.

        You can modify the following information for the funding instruction:
        -    Merchant ID (MID) of the merchant whose funding balance you want to distribute.
        -    Funding account that you want to send funds to.
        -    Amount that you want to send to the funding account.

        Parameters
        ----------
        instruction_id_ : int
            Unique identifier that we assigned to the funding instruction.

        instruction_id : typing.Optional[int]
            Unique identifier that we assigned to the funding instruction.

        created_date : typing.Optional[str]
            Date that we created the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        last_modified_date : typing.Optional[str]
            Date of the most recent change to the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        status : typing.Optional[InstructionStatus]
            Status of the funding instruction. Our gateway returns one of the following values:
            - `accepted` - We have received the funding instruction but have not yet reviewed it.
            - `pending` - We have received the funding instruction and we are reviewing it.
            - `completed` - We have reviewed and processed the funding instruction.

        merchants : typing.Optional[typing.Sequence[InstructionMerchantsItem]]
            Array of merchants objects. Each object specifies the merchant whose funding balance we distribute and who you want to send the funds to.

        metadata : typing.Optional[typing.Dict[str, str]]
            [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"funding-instructions/{jsonable_encoder(instruction_id_)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PUT",
            json={
                "instructionId": instruction_id,
                "createdDate": created_date,
                "lastModifiedDate": last_modified_date,
                "status": status,
                "merchants": convert_and_respect_annotation_metadata(
                    object_=merchants, annotation=typing.Sequence[InstructionMerchantsItem], direction="write"
                ),
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, instruction_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        > **Important:** You can delete a funding instruction only if its status is `accepted`. To view the status of a funding instruction, use our [Retrieve Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/retrieve) method.

        Use this method to delete a funding instruction.

        To delete a funding instruction, you need its instructionId. Our gateway returned the instructionId in the response of the [Create Funding Instruction](https://docs.payroc.com/api/schema/funding/funding-instructions/create) method.

        **Note:** If you don't have the instructionId, use our [List Funding Instructions](https://docs.payroc.com/api/schema/funding/funding-instructions/list) method to search for the funding instruction.

        Parameters
        ----------
        instruction_id : int
            Unique identifier that we assigned to the funding instruction.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"funding-instructions/{jsonable_encoder(instruction_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
