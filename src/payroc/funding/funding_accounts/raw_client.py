# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.custom_pagination import AsyncPayrocPager, SyncPayrocPager
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.funding_account import FundingAccount
from ...types.funding_account_status import FundingAccountStatus
from ...types.funding_account_type import FundingAccountType
from ...types.funding_account_use import FundingAccountUse
from ...types.link import Link
from ...types.list_funding_accounts import ListFundingAccounts
from ...types.payment_methods import PaymentMethods

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawFundingAccountsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[FundingAccount, ListFundingAccounts]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of funding accounts associated with your account.

        **Note:** If you want to view the details of a specific funding account and you have its fundingAccountId, use our [Retrieve Funding Account](https://docs.payroc.com/api/schema/funding/funding-accounts/retrieve) method.

        Our gateway returns the following information about each funding account in the list:
        - Name of the account holder and ACH details for the account.
        - Status of the account.
        - Whether we send funds to the account, withdraw funds from the account, or both.

        For each funding account, we also return the fundingAccountId, which you can use to perform follow-on actions.

        Parameters
        ----------
        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[FundingAccount, ListFundingAccounts]
            Successful request. Returns a paginated list of all funding accounts.
        """
        _response = self._client_wrapper.httpx_client.request(
            "funding-accounts",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListFundingAccounts,
                    parse_obj_as(
                        type_=ListFundingAccounts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self, funding_account_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[FundingAccount]:
        """
        Use this method to retrieve information about a funding account.

        To retrieve a funding account, you need its fundingAccountId. Our gateway returned the fundingAccountId when you created the funding account.

        **Note:** If you don't have the fundingAccountId, use our [List Funding Accounts](https://docs.payroc.com/api/schema/funding/funding-accounts/list) method to search for the account.

        Our gateway returns the following information about the funding account:
        - Name of the account holder and ACH details for the account.
        - Status of the account.
        - Whether we send funds to the account, withdraw funds from the account, or both.

        Parameters
        ----------
        funding_account_id : int
            Unique identifier of the funding account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FundingAccount]
            Successful request. Returns the requested funding account.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"funding-accounts/{jsonable_encoder(funding_account_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FundingAccount,
                    parse_obj_as(
                        type_=FundingAccount,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        funding_account_id_: int,
        *,
        type: FundingAccountType,
        use: FundingAccountUse,
        name_on_account: str,
        payment_methods: PaymentMethods,
        funding_account_id: typing.Optional[int] = OMIT,
        created_date: typing.Optional[dt.datetime] = OMIT,
        last_modified_date: typing.Optional[dt.datetime] = OMIT,
        status: typing.Optional[FundingAccountStatus] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        links: typing.Optional[typing.Sequence[Link]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        > **Important:** You can't update the details of a funding account that is associated with a processing account.

        Use this method to update the details of a funding account that is associated with a funding recipient.

        To update a funding account, you need its fundingAccountId. Our gateway returned the fundingAccountId when you created the funding account.

        **Note:** If you don’t have the fundingAccountId, use our [List Funding Accounts](https://docs.payroc.com/api/schema/funding/funding-accounts/list) method to search for the funding account.

        You can update the following details about the funding account:
        -    Account type.
        -    Account holder's name.
        -    ACH information for the account.

        Parameters
        ----------
        funding_account_id_ : int
            Unique identifier of the funding account.

        type : FundingAccountType
            Type of funding account.

        use : FundingAccountUse
            Indicates if we send funds or withdraw funds from the account.
            - `credit` - Send funds to the account.
            - `debit` - Withdraw funds from the account.
            - `creditAndDebit` - Send funds and withdraw funds from the account.

            **Note:** If the funding account is associated with a funding recipient, we accept only a value of `credit`.

        name_on_account : str
            Name of the account holder.

        payment_methods : PaymentMethods
            Array of paymentMethod objects.

        funding_account_id : typing.Optional[int]
            Unique identifier that we assigned to the funding account.

        created_date : typing.Optional[dt.datetime]
            Date and time that we received your request to create the funding account in our system.

        last_modified_date : typing.Optional[dt.datetime]
            Date and time that the funding account was last modified.

        status : typing.Optional[FundingAccountStatus]
            Status of the funding account. The value is one of the following:
            - `approved` - We approved the funding account.
            - `rejected` - We rejected the funding account.
            - `pending` - We have not yet approved the funding account.
            - `hold` - Our Risk team have temporarily placed a hold on the funding account.

        metadata : typing.Optional[typing.Dict[str, str]]
            [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.

        links : typing.Optional[typing.Sequence[Link]]
            Array of HATEOAS links.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"funding-accounts/{jsonable_encoder(funding_account_id_)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PUT",
            json={
                "fundingAccountId": funding_account_id,
                "createdDate": created_date,
                "lastModifiedDate": last_modified_date,
                "status": status,
                "type": type,
                "use": use,
                "nameOnAccount": name_on_account,
                "paymentMethods": convert_and_respect_annotation_metadata(
                    object_=payment_methods, annotation=PaymentMethods, direction="write"
                ),
                "metadata": metadata,
                "links": convert_and_respect_annotation_metadata(
                    object_=links, annotation=typing.Sequence[Link], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self, funding_account_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        > **Important:** You can't delete a funding account that is associated with a processing account.

        Use this method to delete a funding account that is associated with a funding recipient.

        To delete a funding account, you need its fundingAccountId. Our gateway returned the fundingAccountId when you created the funding account.

        **Note:** If you don't have the fundingAccountId, use our [List Funding Accounts](https://docs.payroc.com/api/schema/funding/funding-accounts/list) method to search for the funding account.

        Parameters
        ----------
        funding_account_id : int
            Unique identifier of the funding account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"funding-accounts/{jsonable_encoder(funding_account_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawFundingAccountsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[FundingAccount, ListFundingAccounts]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of funding accounts associated with your account.

        **Note:** If you want to view the details of a specific funding account and you have its fundingAccountId, use our [Retrieve Funding Account](https://docs.payroc.com/api/schema/funding/funding-accounts/retrieve) method.

        Our gateway returns the following information about each funding account in the list:
        - Name of the account holder and ACH details for the account.
        - Status of the account.
        - Whether we send funds to the account, withdraw funds from the account, or both.

        For each funding account, we also return the fundingAccountId, which you can use to perform follow-on actions.

        Parameters
        ----------
        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[FundingAccount, ListFundingAccounts]
            Successful request. Returns a paginated list of all funding accounts.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "funding-accounts",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListFundingAccounts,
                    parse_obj_as(
                        type_=ListFundingAccounts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self, funding_account_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[FundingAccount]:
        """
        Use this method to retrieve information about a funding account.

        To retrieve a funding account, you need its fundingAccountId. Our gateway returned the fundingAccountId when you created the funding account.

        **Note:** If you don't have the fundingAccountId, use our [List Funding Accounts](https://docs.payroc.com/api/schema/funding/funding-accounts/list) method to search for the account.

        Our gateway returns the following information about the funding account:
        - Name of the account holder and ACH details for the account.
        - Status of the account.
        - Whether we send funds to the account, withdraw funds from the account, or both.

        Parameters
        ----------
        funding_account_id : int
            Unique identifier of the funding account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FundingAccount]
            Successful request. Returns the requested funding account.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"funding-accounts/{jsonable_encoder(funding_account_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FundingAccount,
                    parse_obj_as(
                        type_=FundingAccount,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        funding_account_id_: int,
        *,
        type: FundingAccountType,
        use: FundingAccountUse,
        name_on_account: str,
        payment_methods: PaymentMethods,
        funding_account_id: typing.Optional[int] = OMIT,
        created_date: typing.Optional[dt.datetime] = OMIT,
        last_modified_date: typing.Optional[dt.datetime] = OMIT,
        status: typing.Optional[FundingAccountStatus] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        links: typing.Optional[typing.Sequence[Link]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        > **Important:** You can't update the details of a funding account that is associated with a processing account.

        Use this method to update the details of a funding account that is associated with a funding recipient.

        To update a funding account, you need its fundingAccountId. Our gateway returned the fundingAccountId when you created the funding account.

        **Note:** If you don’t have the fundingAccountId, use our [List Funding Accounts](https://docs.payroc.com/api/schema/funding/funding-accounts/list) method to search for the funding account.

        You can update the following details about the funding account:
        -    Account type.
        -    Account holder's name.
        -    ACH information for the account.

        Parameters
        ----------
        funding_account_id_ : int
            Unique identifier of the funding account.

        type : FundingAccountType
            Type of funding account.

        use : FundingAccountUse
            Indicates if we send funds or withdraw funds from the account.
            - `credit` - Send funds to the account.
            - `debit` - Withdraw funds from the account.
            - `creditAndDebit` - Send funds and withdraw funds from the account.

            **Note:** If the funding account is associated with a funding recipient, we accept only a value of `credit`.

        name_on_account : str
            Name of the account holder.

        payment_methods : PaymentMethods
            Array of paymentMethod objects.

        funding_account_id : typing.Optional[int]
            Unique identifier that we assigned to the funding account.

        created_date : typing.Optional[dt.datetime]
            Date and time that we received your request to create the funding account in our system.

        last_modified_date : typing.Optional[dt.datetime]
            Date and time that the funding account was last modified.

        status : typing.Optional[FundingAccountStatus]
            Status of the funding account. The value is one of the following:
            - `approved` - We approved the funding account.
            - `rejected` - We rejected the funding account.
            - `pending` - We have not yet approved the funding account.
            - `hold` - Our Risk team have temporarily placed a hold on the funding account.

        metadata : typing.Optional[typing.Dict[str, str]]
            [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.

        links : typing.Optional[typing.Sequence[Link]]
            Array of HATEOAS links.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"funding-accounts/{jsonable_encoder(funding_account_id_)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PUT",
            json={
                "fundingAccountId": funding_account_id,
                "createdDate": created_date,
                "lastModifiedDate": last_modified_date,
                "status": status,
                "type": type,
                "use": use,
                "nameOnAccount": name_on_account,
                "paymentMethods": convert_and_respect_annotation_metadata(
                    object_=payment_methods, annotation=PaymentMethods, direction="write"
                ),
                "metadata": metadata,
                "links": convert_and_respect_annotation_metadata(
                    object_=links, annotation=typing.Sequence[Link], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, funding_account_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        > **Important:** You can't delete a funding account that is associated with a processing account.

        Use this method to delete a funding account that is associated with a funding recipient.

        To delete a funding account, you need its fundingAccountId. Our gateway returned the fundingAccountId when you created the funding account.

        **Note:** If you don't have the fundingAccountId, use our [List Funding Accounts](https://docs.payroc.com/api/schema/funding/funding-accounts/list) method to search for the funding account.

        Parameters
        ----------
        funding_account_id : int
            Unique identifier of the funding account.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"funding-accounts/{jsonable_encoder(funding_account_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
