# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.custom_pagination import AsyncPayrocPager, SyncPayrocPager
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ...types.custom_field import CustomField
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_fifteen import FourHundredFifteen
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_nine import FourHundredNine
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.patch_request import PatchRequest
from ...types.subscription import Subscription
from ...types.subscription_paginated_list import SubscriptionPaginatedList
from ...types.subscription_payment import SubscriptionPayment
from ...types.subscription_payment_order import SubscriptionPaymentOrder
from ...types.subscription_payment_order_request import SubscriptionPaymentOrderRequest
from ...types.subscription_recurring_order_request import SubscriptionRecurringOrderRequest
from .types.list_subscriptions_request_frequency import ListSubscriptionsRequestFrequency
from .types.list_subscriptions_request_status import ListSubscriptionsRequestStatus
from .types.subscription_request_payment_method import SubscriptionRequestPaymentMethod

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawSubscriptionsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        processing_terminal_id: str,
        *,
        customer_name: typing.Optional[str] = None,
        last_4: typing.Optional[str] = None,
        payment_plan: typing.Optional[str] = None,
        frequency: typing.Optional[ListSubscriptionsRequestFrequency] = None,
        status: typing.Optional[ListSubscriptionsRequestStatus] = None,
        end_date: typing.Optional[dt.date] = None,
        next_due_date: typing.Optional[dt.date] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[Subscription, SubscriptionPaginatedList]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of subscriptions.

        Note: If you want to view the details of a specific subscription and you have its subscriptionId, use our [Retrieve subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve) method.

        Use query parameters to filter the list of results that we return, for example, to search for subscriptions for a customer, a payment plan, or frequency.

        Our gateway returns information about the following for each subscription in the list:

        -    Payment plan the subscription is linked to.
        -    Secure token that represents cardholder’s payment details.
        -    Current state of the subscription, including its status, next due date, and invoices.
        -    Fees for setup and the cost of the recurring order.
        -    Subscription length, end date, and frequency.

        For each subscription, we also return the subscriptionId, the paymentPlanId, and the secureTokenId, which you can use to perform follow-actions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        customer_name : typing.Optional[str]
            Filter by the customer's name.

        last_4 : typing.Optional[str]
            Filter by the last four digits of the card or account number.

        payment_plan : typing.Optional[str]
            Filter by the name of the payment plan.

        frequency : typing.Optional[ListSubscriptionsRequestFrequency]
            Filter by the frequency of subscription payments.

        status : typing.Optional[ListSubscriptionsRequestStatus]
            Filter by the current status of the subscription.

        end_date : typing.Optional[dt.date]
            Format: `YYYY-MM-DD`
            Filter subscriptions that end on a specific date.

        next_due_date : typing.Optional[dt.date]
            Format: `YYYY-MM-DD`
            Filter subscriptions by the date that the next payment is collected.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[Subscription, SubscriptionPaginatedList]
            Successful request. Returns a paginated list of subscriptions.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "customerName": customer_name,
                "last4": last_4,
                "paymentPlan": payment_plan,
                "frequency": frequency,
                "status": status,
                "endDate": str(end_date) if end_date is not None else None,
                "nextDueDate": str(next_due_date) if next_due_date is not None else None,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    SubscriptionPaginatedList,
                    parse_obj_as(
                        type_=SubscriptionPaginatedList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        processing_terminal_id: str,
        *,
        idempotency_key: str,
        subscription_id: str,
        payment_plan_id: str,
        payment_method: SubscriptionRequestPaymentMethod,
        start_date: dt.date,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        setup_order: typing.Optional[SubscriptionPaymentOrderRequest] = OMIT,
        recurring_order: typing.Optional[SubscriptionRecurringOrderRequest] = OMIT,
        end_date: typing.Optional[dt.date] = OMIT,
        length: typing.Optional[int] = OMIT,
        pause_collection_for: typing.Optional[int] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Subscription]:
        """
        Use this method to assign a customer to a payment plan.

        **Note:** This method is part of our Repeat Payments feature. To help you understand how this method works with our Payment plans endpoints, go to [Repeat Payments](https://docs.payroc.com/guides/take-payments/repeat-payments).

        When you create a subscription you need to provide a unique subscriptionId that you use to run follow-on actions:

        - [Retrieve Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve) - View the details of the subscription.
        - [Update Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/partially-update) - Update the details of the subscription.
        - [Deactivate Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate) - Stop taking payments for the subscription.
        - [Re-activate Subscription](https://docs.payroc.com/api/schema/payments/subscriptions/reactivate) - Start taking payments again for the subscription.
        - [Pay Manual Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/pay) - Manually collect a payment for the subscription.

        The request includes the following settings:
        - **paymentPlanId** - Unique identifier of the payment plan that the merchant wants to use. If you don't have the paymentPlanId, use our [List Payment Plans](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list) method to search for the payment plan.
        - **paymentMethod** - Object that contains information about the secure token, which represents the customer's card details or bank account details.
        - **startDate** - Date that you want to start to take payments.

        You can also update the settings that the subscription inherited from the payment plan, for example, you can change the amount for each payment. If you change the settings for the subscription, it doesn't change the settings in the payment plan that it's linked to.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        payment_plan_id : str
            Unique identifier that the merchant assigned to the payment plan.

        payment_method : SubscriptionRequestPaymentMethod
            Polymorphic object that contains information about the secure token.

        start_date : dt.date
            Format: **YYYY-MM-DD**
            Subscription's start date.

        name : typing.Optional[str]
            Name of the subscription.
            This value replaces the name inherited from the payment plan.

        description : typing.Optional[str]
            Description of the subscription.
            This value replaces the description inherited from the payment plan.

        setup_order : typing.Optional[SubscriptionPaymentOrderRequest]

        recurring_order : typing.Optional[SubscriptionRecurringOrderRequest]

        end_date : typing.Optional[dt.date]
            Format: **YYYY-MM-DD**
            Subscription's end date.
            **Note:** If you provide values for both **length** and **endDate**,
            our gateway uses the value for **endDate** to determine when the subscription should end.

        length : typing.Optional[int]
            Total number of billing cycles. To indicate that the subscription should run indefinitely, send a value of `0`.
            This value replaces the **length** inherited from the payment plan.
            **Note:** If you provide values for both **length** and **endDate**,
            our gateway uses the value for **endDate** to determine when the subscription should end.

        pause_collection_for : typing.Optional[int]
            Number of billing cycles that the merchant wants to pause payments for.
            For example, if the merchant wants to offer a free trial period.

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Subscription]
            Successful request. We created the subscription.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "subscriptionId": subscription_id,
                "paymentPlanId": payment_plan_id,
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=SubscriptionRequestPaymentMethod, direction="write"
                ),
                "name": name,
                "description": description,
                "setupOrder": convert_and_respect_annotation_metadata(
                    object_=setup_order, annotation=SubscriptionPaymentOrderRequest, direction="write"
                ),
                "recurringOrder": convert_and_respect_annotation_metadata(
                    object_=recurring_order, annotation=SubscriptionRecurringOrderRequest, direction="write"
                ),
                "startDate": start_date,
                "endDate": end_date,
                "length": length,
                "pauseCollectionFor": pause_collection_for,
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Subscription]:
        """
        Use this method to retrieve information about a subscription.

        To retrieve a subscription, you need its subscriptionId. You sent the subscriptionId in the request of the [Create subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the subscription.

        Our gateway returns information about the following for the subscription:

        -    Payment plan the subscription is linked to.
        -    Secure token that represents cardholder’s payment details.
        -    Current state of the subscription, including its status, next due date, and invoices.
        -    Fees for setup and the cost of the recurring order.
        -    Subscription length, end date, and frequency.

        We also return the paymentPlanId and the secureTokenId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Subscription]
            Successful request. Returns the requested subscription.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def partially_update(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        idempotency_key: str,
        request: PatchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Subscription]:
        """
        Use this method to partially update a subscription. Structure your request to follow the [RFC 6902](https://datatracker.ietf.org/doc/html/rfc6902) standard.

        To update a subscription, you need its subscriptionId, which you sent in the request of the [Create subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the payment.

        You can update all of the properties of the subscription except for the following:

        **Can't delete**
        - recurringOrder
        - description
        - name

        **Can't perform any PATCH operation**
        - currentState
        - type
        - frequency
        - paymentPlan

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : PatchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Subscription]
            Successful request. We have updated the subscription.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PATCH",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=PatchRequest, direction="write"),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deactivate(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Subscription]:
        """
        Use this method to deactivate a subscription.

        To deactivate a subscription, you need its subscriptionId, which you sent in the request of the [Create Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List Subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the subscription.

        If your request is successful, our gateway stops taking payments from the customer.

        To reactivate the subscription, use our [Reactivate Subscription](https://docs.payroc.com/api/schema/payments/subscriptions/reactivate) method.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Subscription]
            Successful request. We deactivated the subscription.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}/deactivate",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def reactivate(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Subscription]:
        """
        Use this method to reactivate a subscription.

        To reactivate a subscription, you need its subscriptionId, which you sent in the request of the [Create Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List Subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the subscription.

        If your request is successful, our gateway restarts taking payments from the customer.

        To deactivate the subscription, use our [Deactivate Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate) method.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Subscription]
            Successful request. We re-activated the subscription.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}/reactivate",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def pay(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        idempotency_key: str,
        order: SubscriptionPaymentOrder,
        operator: typing.Optional[str] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SubscriptionPayment]:
        """
        Use this method to manually collect a payment linked to a subscription. You can manually collect a payment only if the merchant chose not to let our gateway automatically collect each payment.

        To manually collect a payment, you need the subscriptionId of the subscription that's linked to the payment. You sent the subscriptionId in the request of the [Create Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List Subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the subscription.

        The request includes an order object that contains information about the amount that you want to collect.

        In the response, our gateway returns information about the payment and a paymentId. You can use the paymentId in follow-on actions with the [Payments](https://docs.payroc.com/api/schema/card-payments/payments) endpoints or [Bank Transfer Payments](https://docs.payroc.com/api/schema/bank-transfer-payments/payments) endpoints.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        order : SubscriptionPaymentOrder
            Object that contains information about the payment.

        operator : typing.Optional[str]
            Operator who initiated the request.

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SubscriptionPayment]
            Successful request. We have processed the payment for the subscription.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}/pay",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "operator": operator,
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=SubscriptionPaymentOrder, direction="write"
                ),
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SubscriptionPayment,
                    parse_obj_as(
                        type_=SubscriptionPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawSubscriptionsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        processing_terminal_id: str,
        *,
        customer_name: typing.Optional[str] = None,
        last_4: typing.Optional[str] = None,
        payment_plan: typing.Optional[str] = None,
        frequency: typing.Optional[ListSubscriptionsRequestFrequency] = None,
        status: typing.Optional[ListSubscriptionsRequestStatus] = None,
        end_date: typing.Optional[dt.date] = None,
        next_due_date: typing.Optional[dt.date] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[Subscription, SubscriptionPaginatedList]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of subscriptions.

        Note: If you want to view the details of a specific subscription and you have its subscriptionId, use our [Retrieve subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve) method.

        Use query parameters to filter the list of results that we return, for example, to search for subscriptions for a customer, a payment plan, or frequency.

        Our gateway returns information about the following for each subscription in the list:

        -    Payment plan the subscription is linked to.
        -    Secure token that represents cardholder’s payment details.
        -    Current state of the subscription, including its status, next due date, and invoices.
        -    Fees for setup and the cost of the recurring order.
        -    Subscription length, end date, and frequency.

        For each subscription, we also return the subscriptionId, the paymentPlanId, and the secureTokenId, which you can use to perform follow-actions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        customer_name : typing.Optional[str]
            Filter by the customer's name.

        last_4 : typing.Optional[str]
            Filter by the last four digits of the card or account number.

        payment_plan : typing.Optional[str]
            Filter by the name of the payment plan.

        frequency : typing.Optional[ListSubscriptionsRequestFrequency]
            Filter by the frequency of subscription payments.

        status : typing.Optional[ListSubscriptionsRequestStatus]
            Filter by the current status of the subscription.

        end_date : typing.Optional[dt.date]
            Format: `YYYY-MM-DD`
            Filter subscriptions that end on a specific date.

        next_due_date : typing.Optional[dt.date]
            Format: `YYYY-MM-DD`
            Filter subscriptions by the date that the next payment is collected.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[Subscription, SubscriptionPaginatedList]
            Successful request. Returns a paginated list of subscriptions.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "customerName": customer_name,
                "last4": last_4,
                "paymentPlan": payment_plan,
                "frequency": frequency,
                "status": status,
                "endDate": str(end_date) if end_date is not None else None,
                "nextDueDate": str(next_due_date) if next_due_date is not None else None,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    SubscriptionPaginatedList,
                    parse_obj_as(
                        type_=SubscriptionPaginatedList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        processing_terminal_id: str,
        *,
        idempotency_key: str,
        subscription_id: str,
        payment_plan_id: str,
        payment_method: SubscriptionRequestPaymentMethod,
        start_date: dt.date,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        setup_order: typing.Optional[SubscriptionPaymentOrderRequest] = OMIT,
        recurring_order: typing.Optional[SubscriptionRecurringOrderRequest] = OMIT,
        end_date: typing.Optional[dt.date] = OMIT,
        length: typing.Optional[int] = OMIT,
        pause_collection_for: typing.Optional[int] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Subscription]:
        """
        Use this method to assign a customer to a payment plan.

        **Note:** This method is part of our Repeat Payments feature. To help you understand how this method works with our Payment plans endpoints, go to [Repeat Payments](https://docs.payroc.com/guides/take-payments/repeat-payments).

        When you create a subscription you need to provide a unique subscriptionId that you use to run follow-on actions:

        - [Retrieve Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve) - View the details of the subscription.
        - [Update Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/partially-update) - Update the details of the subscription.
        - [Deactivate Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate) - Stop taking payments for the subscription.
        - [Re-activate Subscription](https://docs.payroc.com/api/schema/payments/subscriptions/reactivate) - Start taking payments again for the subscription.
        - [Pay Manual Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/pay) - Manually collect a payment for the subscription.

        The request includes the following settings:
        - **paymentPlanId** - Unique identifier of the payment plan that the merchant wants to use. If you don't have the paymentPlanId, use our [List Payment Plans](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list) method to search for the payment plan.
        - **paymentMethod** - Object that contains information about the secure token, which represents the customer's card details or bank account details.
        - **startDate** - Date that you want to start to take payments.

        You can also update the settings that the subscription inherited from the payment plan, for example, you can change the amount for each payment. If you change the settings for the subscription, it doesn't change the settings in the payment plan that it's linked to.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        payment_plan_id : str
            Unique identifier that the merchant assigned to the payment plan.

        payment_method : SubscriptionRequestPaymentMethod
            Polymorphic object that contains information about the secure token.

        start_date : dt.date
            Format: **YYYY-MM-DD**
            Subscription's start date.

        name : typing.Optional[str]
            Name of the subscription.
            This value replaces the name inherited from the payment plan.

        description : typing.Optional[str]
            Description of the subscription.
            This value replaces the description inherited from the payment plan.

        setup_order : typing.Optional[SubscriptionPaymentOrderRequest]

        recurring_order : typing.Optional[SubscriptionRecurringOrderRequest]

        end_date : typing.Optional[dt.date]
            Format: **YYYY-MM-DD**
            Subscription's end date.
            **Note:** If you provide values for both **length** and **endDate**,
            our gateway uses the value for **endDate** to determine when the subscription should end.

        length : typing.Optional[int]
            Total number of billing cycles. To indicate that the subscription should run indefinitely, send a value of `0`.
            This value replaces the **length** inherited from the payment plan.
            **Note:** If you provide values for both **length** and **endDate**,
            our gateway uses the value for **endDate** to determine when the subscription should end.

        pause_collection_for : typing.Optional[int]
            Number of billing cycles that the merchant wants to pause payments for.
            For example, if the merchant wants to offer a free trial period.

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Subscription]
            Successful request. We created the subscription.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "subscriptionId": subscription_id,
                "paymentPlanId": payment_plan_id,
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=SubscriptionRequestPaymentMethod, direction="write"
                ),
                "name": name,
                "description": description,
                "setupOrder": convert_and_respect_annotation_metadata(
                    object_=setup_order, annotation=SubscriptionPaymentOrderRequest, direction="write"
                ),
                "recurringOrder": convert_and_respect_annotation_metadata(
                    object_=recurring_order, annotation=SubscriptionRecurringOrderRequest, direction="write"
                ),
                "startDate": start_date,
                "endDate": end_date,
                "length": length,
                "pauseCollectionFor": pause_collection_for,
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Subscription]:
        """
        Use this method to retrieve information about a subscription.

        To retrieve a subscription, you need its subscriptionId. You sent the subscriptionId in the request of the [Create subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the subscription.

        Our gateway returns information about the following for the subscription:

        -    Payment plan the subscription is linked to.
        -    Secure token that represents cardholder’s payment details.
        -    Current state of the subscription, including its status, next due date, and invoices.
        -    Fees for setup and the cost of the recurring order.
        -    Subscription length, end date, and frequency.

        We also return the paymentPlanId and the secureTokenId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Subscription]
            Successful request. Returns the requested subscription.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def partially_update(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        idempotency_key: str,
        request: PatchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Subscription]:
        """
        Use this method to partially update a subscription. Structure your request to follow the [RFC 6902](https://datatracker.ietf.org/doc/html/rfc6902) standard.

        To update a subscription, you need its subscriptionId, which you sent in the request of the [Create subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the payment.

        You can update all of the properties of the subscription except for the following:

        **Can't delete**
        - recurringOrder
        - description
        - name

        **Can't perform any PATCH operation**
        - currentState
        - type
        - frequency
        - paymentPlan

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : PatchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Subscription]
            Successful request. We have updated the subscription.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PATCH",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=PatchRequest, direction="write"),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deactivate(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Subscription]:
        """
        Use this method to deactivate a subscription.

        To deactivate a subscription, you need its subscriptionId, which you sent in the request of the [Create Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List Subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the subscription.

        If your request is successful, our gateway stops taking payments from the customer.

        To reactivate the subscription, use our [Reactivate Subscription](https://docs.payroc.com/api/schema/payments/subscriptions/reactivate) method.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Subscription]
            Successful request. We deactivated the subscription.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}/deactivate",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def reactivate(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Subscription]:
        """
        Use this method to reactivate a subscription.

        To reactivate a subscription, you need its subscriptionId, which you sent in the request of the [Create Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List Subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the subscription.

        If your request is successful, our gateway restarts taking payments from the customer.

        To deactivate the subscription, use our [Deactivate Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate) method.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Subscription]
            Successful request. We re-activated the subscription.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}/reactivate",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Subscription,
                    parse_obj_as(
                        type_=Subscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def pay(
        self,
        processing_terminal_id: str,
        subscription_id: str,
        *,
        idempotency_key: str,
        order: SubscriptionPaymentOrder,
        operator: typing.Optional[str] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SubscriptionPayment]:
        """
        Use this method to manually collect a payment linked to a subscription. You can manually collect a payment only if the merchant chose not to let our gateway automatically collect each payment.

        To manually collect a payment, you need the subscriptionId of the subscription that's linked to the payment. You sent the subscriptionId in the request of the [Create Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create) method.

        **Note:** If you don't have the subscriptionId, use our [List Subscriptions](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list) method to search for the subscription.

        The request includes an order object that contains information about the amount that you want to collect.

        In the response, our gateway returns information about the payment and a paymentId. You can use the paymentId in follow-on actions with the [Payments](https://docs.payroc.com/api/schema/card-payments/payments) endpoints or [Bank Transfer Payments](https://docs.payroc.com/api/schema/bank-transfer-payments/payments) endpoints.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        subscription_id : str
            Unique identifier that the merchant assigned to the subscription.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        order : SubscriptionPaymentOrder
            Object that contains information about the payment.

        operator : typing.Optional[str]
            Operator who initiated the request.

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SubscriptionPayment]
            Successful request. We have processed the payment for the subscription.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/subscriptions/{jsonable_encoder(subscription_id)}/pay",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "operator": operator,
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=SubscriptionPaymentOrder, direction="write"
                ),
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SubscriptionPayment,
                    parse_obj_as(
                        type_=SubscriptionPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
