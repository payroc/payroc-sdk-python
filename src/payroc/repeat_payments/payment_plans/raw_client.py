# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.custom_pagination import AsyncPayrocPager, SyncPayrocPager
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ...types.currency import Currency
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_fifteen import FourHundredFifteen
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_nine import FourHundredNine
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.patch_request import PatchRequest
from ...types.payment_plan import PaymentPlan
from ...types.payment_plan_base_frequency import PaymentPlanBaseFrequency
from ...types.payment_plan_base_on_delete import PaymentPlanBaseOnDelete
from ...types.payment_plan_base_on_update import PaymentPlanBaseOnUpdate
from ...types.payment_plan_base_type import PaymentPlanBaseType
from ...types.payment_plan_paginated_list import PaymentPlanPaginatedList
from ...types.payment_plan_recurring_order import PaymentPlanRecurringOrder
from ...types.payment_plan_setup_order import PaymentPlanSetupOrder

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawPaymentPlansClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        processing_terminal_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[PaymentPlan, PaymentPlanPaginatedList]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of payment plans for a processing terminal.

        **Note:** If you want to view the details of a specific payment plan and you have its paymentPlanId, use our [Retrieve Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/retrieve) method.

        Our gateway returns the following information about each payment plan in the list:

          -    Name, length, and currency of the plan
          -    How often our gateway collects each payment
          -    How much our gateway collects for each payment
          -    What happens if the merchant updates or deletes the plan

        For each payment plan, we return the paymentPlanId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[PaymentPlan, PaymentPlanPaginatedList]
            Successful request. Returns a paginated list of payment plans.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/payment-plans",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaymentPlanPaginatedList,
                    parse_obj_as(
                        type_=PaymentPlanPaginatedList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        processing_terminal_id_: str,
        *,
        idempotency_key: str,
        payment_plan_id: str,
        name: str,
        currency: Currency,
        type: PaymentPlanBaseType,
        frequency: PaymentPlanBaseFrequency,
        on_update: PaymentPlanBaseOnUpdate,
        on_delete: PaymentPlanBaseOnDelete,
        setup_order: typing.Optional[PaymentPlanSetupOrder] = OMIT,
        recurring_order: typing.Optional[PaymentPlanRecurringOrder] = OMIT,
        processing_terminal_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        length: typing.Optional[int] = OMIT,
        custom_field_names: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaymentPlan]:
        """
        Use this method to create a payment schedule that you can assign customers to.

        **Note:** This method is part of our Repeat Payments feature. To help you understand how this method works with our Subscriptions endpoints, go to [Repeat Payments](https://docs.payroc.com/guides/integrate/repeat-payments).

        When you create a payment plan you need to provide a unique paymentPlanId that you use to run follow-on actions:

        -    [Retrieve Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/retrieve)  - View the details of the payment plan.
        -    [Update Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/partially-update)  - Update the details of the payment plan.
        -    [Delete Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/delete)  - Delete the payment plan.
        -    [Create Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create)  - Subscribe a customer to the payment plan.

        The request includes the following settings:

        -    **type** - Indicates if our gateway or the merchant collects payments. If the merchant manually collects payments, integrate with the [Pay Manual Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/pay) method.
        -    **recurringOrder** - Amount of each payment if the gateway automatically collect payments.
        -    **setupOrder** - Setup fee that our gateway immediately collects from the customer's payment method.
        -    **onUpdate and onDelete** - Indicates what happens to associated subscriptions if the merchant updates or deletes the payment plan.

        Parameters
        ----------
        processing_terminal_id_ : str
            Unique identifier that we assigned to the terminal.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        payment_plan_id : str
            Unique identifier that the merchant assigns to the payment plan.

        name : str
            Name of the payment plan.

        currency : Currency

        type : PaymentPlanBaseType
            Indicates how the merchant takes the payment from the customer's account.
            - `manual` - The merchant manually collects payments from the customer.
            - `automatic` - The terminal automatically collects payments from the customer.

        frequency : PaymentPlanBaseFrequency
            Indicates how often the merchant or the terminal collects a payment from the customer.

        on_update : PaymentPlanBaseOnUpdate
            Indicates whether any changes that the merchant makes to the payment plan apply to existing subscriptions.
            - `update` - Changes apply to existing subscriptions.
            - `continue` - Changes don't apply to existing subscriptions.

        on_delete : PaymentPlanBaseOnDelete
            Indicates what happens to existing subscriptions if the merchant deletes the payment plan.
            - `complete` - Stops existing subscriptions.
            - `continue` - Continues existing subscriptions.

        setup_order : typing.Optional[PaymentPlanSetupOrder]

        recurring_order : typing.Optional[PaymentPlanRecurringOrder]

        processing_terminal_id : typing.Optional[str]
            Unique identifier of the terminal that the payment plan is assigned to.

        description : typing.Optional[str]
            Description of the payment plan.

        length : typing.Optional[int]
            Number of payments for the payment plan.

            To indicate that the payment plan should run indefinitely, send a value of `0`.

        custom_field_names : typing.Optional[typing.Sequence[str]]
            Array of custom fields that you can use in subscriptions linked to the payment plan.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaymentPlan]
            Successful request. We created the payment plan.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id_)}/payment-plans",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "setupOrder": convert_and_respect_annotation_metadata(
                    object_=setup_order, annotation=PaymentPlanSetupOrder, direction="write"
                ),
                "recurringOrder": convert_and_respect_annotation_metadata(
                    object_=recurring_order, annotation=PaymentPlanRecurringOrder, direction="write"
                ),
                "paymentPlanId": payment_plan_id,
                "processingTerminalId": processing_terminal_id,
                "name": name,
                "description": description,
                "currency": currency,
                "length": length,
                "type": type,
                "frequency": frequency,
                "onUpdate": on_update,
                "onDelete": on_delete,
                "customFieldNames": custom_field_names,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaymentPlan,
                    parse_obj_as(
                        type_=PaymentPlan,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self,
        processing_terminal_id: str,
        payment_plan_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaymentPlan]:
        """
        Use this method to retrieve information about a payment plan.

        To retrieve a payment plan, you need its paymentPlanId. Our gateway returned the paymentPlanId in the response of the [Create Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/create) method.

        **Note:** If you don't have the paymentPlanId, use our [List Payment Plans](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list) method to search for the payment plan.

        Our gateway returns the following information about the payment plan:

          -    Name, length, and currency of the plan
          -    How often our gateway collects each payment
          -    How much our gateway collects for each payment
          -    What happens if the merchant updates or deletes the plan

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        payment_plan_id : str
            Unique identifier that the merchant assigned to the payment plan.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaymentPlan]
            Successful request. Returns the requested payment plan.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/payment-plans/{jsonable_encoder(payment_plan_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaymentPlan,
                    parse_obj_as(
                        type_=PaymentPlan,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        processing_terminal_id: str,
        payment_plan_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Use this method to delete a payment plan.

        > **Important:** When you delete a payment plan, you can’t recover it. You also won’t be able to add subscriptions to the payment plan.

        To delete a payment plan, you need its paymentPlanId, which you sent in the request of the [Create Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/create) method.

        **Note:** If you don't have the paymentPlanId, use our [List Payment Plans](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list) method to search for the payment plan.

        The value you sent for the onDelete parameter when you created the payment plan indicates what happens to associated subscriptions when you delete the plan:

          -    `complete` - Our gateway stops taking payments for the subscriptions associated with the payment plan.
          -    `continue` - Our gateway continues to take payments for the subscriptions associated with the payment plan. To stop a subscription for a cancelled payment plan, go to the [Deactivate Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate) method.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        payment_plan_id : str
            Unique identifier that the merchant assigned to the payment plan.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/payment-plans/{jsonable_encoder(payment_plan_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def partially_update(
        self,
        processing_terminal_id: str,
        payment_plan_id: str,
        *,
        idempotency_key: str,
        request: PatchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaymentPlan]:
        """
        Use this method to partially update a payment plan. Structure your request to follow the [RFC 6902](https://datatracker.ietf.org/doc/html/rfc6902) standard.

        To update a payment plan, you need its paymentPlanId, which you sent in the request of the [Create Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/create) method.

        **Note:** If you don't have the paymentPlanId, use our [List Payment Plans](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list) method to search for the payment plan.

        You can update all of the properties of the payment plan except for the paymentPlanId.

        The value you sent for the onUpdate parameter when you created the payment plan indicates what happens to the associated subscriptions when you update the plan:
        - `update` - Our gateway updates the subscriptions associated with the payment plan.
        - `continue` - Our  gateway doesn't update the subscriptions associated with the payment plan.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        payment_plan_id : str
            Unique identifier that the merchant assigned to the payment plan.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : PatchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaymentPlan]
            Successful request. We updated the payment plan.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/payment-plans/{jsonable_encoder(payment_plan_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PATCH",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=PatchRequest, direction="write"),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaymentPlan,
                    parse_obj_as(
                        type_=PaymentPlan,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawPaymentPlansClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        processing_terminal_id: str,
        *,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[PaymentPlan, PaymentPlanPaginatedList]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of payment plans for a processing terminal.

        **Note:** If you want to view the details of a specific payment plan and you have its paymentPlanId, use our [Retrieve Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/retrieve) method.

        Our gateway returns the following information about each payment plan in the list:

          -    Name, length, and currency of the plan
          -    How often our gateway collects each payment
          -    How much our gateway collects for each payment
          -    What happens if the merchant updates or deletes the plan

        For each payment plan, we return the paymentPlanId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[PaymentPlan, PaymentPlanPaginatedList]
            Successful request. Returns a paginated list of payment plans.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/payment-plans",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaymentPlanPaginatedList,
                    parse_obj_as(
                        type_=PaymentPlanPaginatedList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        processing_terminal_id_: str,
        *,
        idempotency_key: str,
        payment_plan_id: str,
        name: str,
        currency: Currency,
        type: PaymentPlanBaseType,
        frequency: PaymentPlanBaseFrequency,
        on_update: PaymentPlanBaseOnUpdate,
        on_delete: PaymentPlanBaseOnDelete,
        setup_order: typing.Optional[PaymentPlanSetupOrder] = OMIT,
        recurring_order: typing.Optional[PaymentPlanRecurringOrder] = OMIT,
        processing_terminal_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        length: typing.Optional[int] = OMIT,
        custom_field_names: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaymentPlan]:
        """
        Use this method to create a payment schedule that you can assign customers to.

        **Note:** This method is part of our Repeat Payments feature. To help you understand how this method works with our Subscriptions endpoints, go to [Repeat Payments](https://docs.payroc.com/guides/integrate/repeat-payments).

        When you create a payment plan you need to provide a unique paymentPlanId that you use to run follow-on actions:

        -    [Retrieve Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/retrieve)  - View the details of the payment plan.
        -    [Update Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/partially-update)  - Update the details of the payment plan.
        -    [Delete Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/delete)  - Delete the payment plan.
        -    [Create Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create)  - Subscribe a customer to the payment plan.

        The request includes the following settings:

        -    **type** - Indicates if our gateway or the merchant collects payments. If the merchant manually collects payments, integrate with the [Pay Manual Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/pay) method.
        -    **recurringOrder** - Amount of each payment if the gateway automatically collect payments.
        -    **setupOrder** - Setup fee that our gateway immediately collects from the customer's payment method.
        -    **onUpdate and onDelete** - Indicates what happens to associated subscriptions if the merchant updates or deletes the payment plan.

        Parameters
        ----------
        processing_terminal_id_ : str
            Unique identifier that we assigned to the terminal.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        payment_plan_id : str
            Unique identifier that the merchant assigns to the payment plan.

        name : str
            Name of the payment plan.

        currency : Currency

        type : PaymentPlanBaseType
            Indicates how the merchant takes the payment from the customer's account.
            - `manual` - The merchant manually collects payments from the customer.
            - `automatic` - The terminal automatically collects payments from the customer.

        frequency : PaymentPlanBaseFrequency
            Indicates how often the merchant or the terminal collects a payment from the customer.

        on_update : PaymentPlanBaseOnUpdate
            Indicates whether any changes that the merchant makes to the payment plan apply to existing subscriptions.
            - `update` - Changes apply to existing subscriptions.
            - `continue` - Changes don't apply to existing subscriptions.

        on_delete : PaymentPlanBaseOnDelete
            Indicates what happens to existing subscriptions if the merchant deletes the payment plan.
            - `complete` - Stops existing subscriptions.
            - `continue` - Continues existing subscriptions.

        setup_order : typing.Optional[PaymentPlanSetupOrder]

        recurring_order : typing.Optional[PaymentPlanRecurringOrder]

        processing_terminal_id : typing.Optional[str]
            Unique identifier of the terminal that the payment plan is assigned to.

        description : typing.Optional[str]
            Description of the payment plan.

        length : typing.Optional[int]
            Number of payments for the payment plan.

            To indicate that the payment plan should run indefinitely, send a value of `0`.

        custom_field_names : typing.Optional[typing.Sequence[str]]
            Array of custom fields that you can use in subscriptions linked to the payment plan.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaymentPlan]
            Successful request. We created the payment plan.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id_)}/payment-plans",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "setupOrder": convert_and_respect_annotation_metadata(
                    object_=setup_order, annotation=PaymentPlanSetupOrder, direction="write"
                ),
                "recurringOrder": convert_and_respect_annotation_metadata(
                    object_=recurring_order, annotation=PaymentPlanRecurringOrder, direction="write"
                ),
                "paymentPlanId": payment_plan_id,
                "processingTerminalId": processing_terminal_id,
                "name": name,
                "description": description,
                "currency": currency,
                "length": length,
                "type": type,
                "frequency": frequency,
                "onUpdate": on_update,
                "onDelete": on_delete,
                "customFieldNames": custom_field_names,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaymentPlan,
                    parse_obj_as(
                        type_=PaymentPlan,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self,
        processing_terminal_id: str,
        payment_plan_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaymentPlan]:
        """
        Use this method to retrieve information about a payment plan.

        To retrieve a payment plan, you need its paymentPlanId. Our gateway returned the paymentPlanId in the response of the [Create Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/create) method.

        **Note:** If you don't have the paymentPlanId, use our [List Payment Plans](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list) method to search for the payment plan.

        Our gateway returns the following information about the payment plan:

          -    Name, length, and currency of the plan
          -    How often our gateway collects each payment
          -    How much our gateway collects for each payment
          -    What happens if the merchant updates or deletes the plan

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        payment_plan_id : str
            Unique identifier that the merchant assigned to the payment plan.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaymentPlan]
            Successful request. Returns the requested payment plan.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/payment-plans/{jsonable_encoder(payment_plan_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaymentPlan,
                    parse_obj_as(
                        type_=PaymentPlan,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        processing_terminal_id: str,
        payment_plan_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Use this method to delete a payment plan.

        > **Important:** When you delete a payment plan, you can’t recover it. You also won’t be able to add subscriptions to the payment plan.

        To delete a payment plan, you need its paymentPlanId, which you sent in the request of the [Create Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/create) method.

        **Note:** If you don't have the paymentPlanId, use our [List Payment Plans](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list) method to search for the payment plan.

        The value you sent for the onDelete parameter when you created the payment plan indicates what happens to associated subscriptions when you delete the plan:

          -    `complete` - Our gateway stops taking payments for the subscriptions associated with the payment plan.
          -    `continue` - Our gateway continues to take payments for the subscriptions associated with the payment plan. To stop a subscription for a cancelled payment plan, go to the [Deactivate Subscription](https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate) method.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        payment_plan_id : str
            Unique identifier that the merchant assigned to the payment plan.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/payment-plans/{jsonable_encoder(payment_plan_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def partially_update(
        self,
        processing_terminal_id: str,
        payment_plan_id: str,
        *,
        idempotency_key: str,
        request: PatchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaymentPlan]:
        """
        Use this method to partially update a payment plan. Structure your request to follow the [RFC 6902](https://datatracker.ietf.org/doc/html/rfc6902) standard.

        To update a payment plan, you need its paymentPlanId, which you sent in the request of the [Create Payment Plan](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/create) method.

        **Note:** If you don't have the paymentPlanId, use our [List Payment Plans](https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list) method to search for the payment plan.

        You can update all of the properties of the payment plan except for the paymentPlanId.

        The value you sent for the onUpdate parameter when you created the payment plan indicates what happens to the associated subscriptions when you update the plan:
        - `update` - Our gateway updates the subscriptions associated with the payment plan.
        - `continue` - Our  gateway doesn't update the subscriptions associated with the payment plan.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        payment_plan_id : str
            Unique identifier that the merchant assigned to the payment plan.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        request : PatchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaymentPlan]
            Successful request. We updated the payment plan.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/payment-plans/{jsonable_encoder(payment_plan_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="PATCH",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=PatchRequest, direction="write"),
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaymentPlan,
                    parse_obj_as(
                        type_=PaymentPlan,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
