# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..errors.conflict_error import ConflictError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_acceptable_error import NotAcceptableError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ..types.five_hundred import FiveHundred
from ..types.four_hundred import FourHundred
from ..types.four_hundred_fifteen import FourHundredFifteen
from ..types.four_hundred_nine import FourHundredNine
from ..types.four_hundred_one import FourHundredOne
from ..types.four_hundred_six import FourHundredSix
from ..types.hosted_fields_create_session_response import HostedFieldsCreateSessionResponse
from .types.hosted_fields_create_session_request_scenario import HostedFieldsCreateSessionRequestScenario

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawHostedFieldsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create(
        self,
        processing_terminal_id: str,
        *,
        idempotency_key: str,
        lib_version: str,
        scenario: HostedFieldsCreateSessionRequestScenario,
        secure_token_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[HostedFieldsCreateSessionResponse]:
        """
        Use this method to create a Hosted Fields session token. You need to generate a new session token each time you load Hosted Fields on a webpage.

        In your request, you need to indicate whether the merchant is using Hosted Fields to run a sale, save payment details, or update saved payment details.

        In the response, our gateway returns the session token and the time that it expires. You need the session token when you configure the JavaScript for Hosted Fields.

        For more information about adding Hosted Fields to a webpage, go to [Hosted Fields](https://docs.payroc.com/guides/take-payments/hosted-fields).

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        lib_version : str
            Version of the Hosted Fields JavaScript library that you are using.

            The current production version is `1.6.0.172441`.

        scenario : HostedFieldsCreateSessionRequestScenario
            Indicates if a merchant wants to take a payment or tokenize a customer's payment details:

            - `payment` - The merchant wants to run a sale or run a sale and tokenize in the same transaction.
            - `tokenization` - The merchant wants to save the customer's payment details to take a payment later or to update a customer's payment details that they've already saved.

        secure_token_id : typing.Optional[str]
            Unique identifier that represents a customer's payment details.

            If a merchant wants to update a customer's payment details that are linked to a secure token, include the secureTokenId in your request.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[HostedFieldsCreateSessionResponse]
            Successful request. We created the session and returned a session token.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/hosted-fields-sessions",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "libVersion": lib_version,
                "scenario": scenario,
                "secureTokenId": secure_token_id,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    HostedFieldsCreateSessionResponse,
                    parse_obj_as(
                        type_=HostedFieldsCreateSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawHostedFieldsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create(
        self,
        processing_terminal_id: str,
        *,
        idempotency_key: str,
        lib_version: str,
        scenario: HostedFieldsCreateSessionRequestScenario,
        secure_token_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[HostedFieldsCreateSessionResponse]:
        """
        Use this method to create a Hosted Fields session token. You need to generate a new session token each time you load Hosted Fields on a webpage.

        In your request, you need to indicate whether the merchant is using Hosted Fields to run a sale, save payment details, or update saved payment details.

        In the response, our gateway returns the session token and the time that it expires. You need the session token when you configure the JavaScript for Hosted Fields.

        For more information about adding Hosted Fields to a webpage, go to [Hosted Fields](https://docs.payroc.com/guides/take-payments/hosted-fields).

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        lib_version : str
            Version of the Hosted Fields JavaScript library that you are using.

            The current production version is `1.6.0.172441`.

        scenario : HostedFieldsCreateSessionRequestScenario
            Indicates if a merchant wants to take a payment or tokenize a customer's payment details:

            - `payment` - The merchant wants to run a sale or run a sale and tokenize in the same transaction.
            - `tokenization` - The merchant wants to save the customer's payment details to take a payment later or to update a customer's payment details that they've already saved.

        secure_token_id : typing.Optional[str]
            Unique identifier that represents a customer's payment details.

            If a merchant wants to update a customer's payment details that are linked to a secure token, include the secureTokenId in your request.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[HostedFieldsCreateSessionResponse]
            Successful request. We created the session and returned a session token.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"processing-terminals/{jsonable_encoder(processing_terminal_id)}/hosted-fields-sessions",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "libVersion": lib_version,
                "scenario": scenario,
                "secureTokenId": secure_token_id,
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    HostedFieldsCreateSessionResponse,
                    parse_obj_as(
                        type_=HostedFieldsCreateSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
