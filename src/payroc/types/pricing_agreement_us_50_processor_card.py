# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from ..core.serialization import FieldMetadata
from .consumer_choice_fees import ConsumerChoiceFees
from .flat_rate_fees import FlatRateFees
from .interchange_plus_fees import InterchangePlusFees
from .interchange_plus_plus_fees import InterchangePlusPlusFees
from .reward_pay_choice_fees import RewardPayChoiceFees
from .tiered_3_fees import Tiered3Fees
from .tiered_4_fees import Tiered4Fees
from .tiered_6_fees import Tiered6Fees


class PricingAgreementUs50ProcessorCard_InterchangePlus(UniversalBaseModel):
    """
    Polymorphic object that contains fees for card transactions.

    The value of the planType field determines which variant you should use:
    -    `interchangePlus` - Interchange + pricing
    -    `interchangePlusPlus` - Interchange pricing with three tiers
    -    `tiered3` - Three-tiered pricing
    -    `tiered4` - Four-tiered pricing
    -    `tiered6` - Six-tiered pricing
    -    `flatRate` - Flat rate pricing
    -    `consumerChoice` - ConsumerChoice
    -    `rewardPayChoice` - RewardPayChoice
    """

    plan_type: typing_extensions.Annotated[
        typing.Literal["interchangePlus"], FieldMetadata(alias="planType"), pydantic.Field(alias="planType")
    ] = "interchangePlus"
    fees: InterchangePlusFees

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PricingAgreementUs50ProcessorCard_InterchangePlusPlus(UniversalBaseModel):
    """
    Polymorphic object that contains fees for card transactions.

    The value of the planType field determines which variant you should use:
    -    `interchangePlus` - Interchange + pricing
    -    `interchangePlusPlus` - Interchange pricing with three tiers
    -    `tiered3` - Three-tiered pricing
    -    `tiered4` - Four-tiered pricing
    -    `tiered6` - Six-tiered pricing
    -    `flatRate` - Flat rate pricing
    -    `consumerChoice` - ConsumerChoice
    -    `rewardPayChoice` - RewardPayChoice
    """

    plan_type: typing_extensions.Annotated[
        typing.Literal["interchangePlusPlus"], FieldMetadata(alias="planType"), pydantic.Field(alias="planType")
    ] = "interchangePlusPlus"
    fees: InterchangePlusPlusFees

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PricingAgreementUs50ProcessorCard_Tiered3(UniversalBaseModel):
    """
    Polymorphic object that contains fees for card transactions.

    The value of the planType field determines which variant you should use:
    -    `interchangePlus` - Interchange + pricing
    -    `interchangePlusPlus` - Interchange pricing with three tiers
    -    `tiered3` - Three-tiered pricing
    -    `tiered4` - Four-tiered pricing
    -    `tiered6` - Six-tiered pricing
    -    `flatRate` - Flat rate pricing
    -    `consumerChoice` - ConsumerChoice
    -    `rewardPayChoice` - RewardPayChoice
    """

    plan_type: typing_extensions.Annotated[
        typing.Literal["tiered3"], FieldMetadata(alias="planType"), pydantic.Field(alias="planType")
    ] = "tiered3"
    fees: Tiered3Fees

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PricingAgreementUs50ProcessorCard_Tiered4(UniversalBaseModel):
    """
    Polymorphic object that contains fees for card transactions.

    The value of the planType field determines which variant you should use:
    -    `interchangePlus` - Interchange + pricing
    -    `interchangePlusPlus` - Interchange pricing with three tiers
    -    `tiered3` - Three-tiered pricing
    -    `tiered4` - Four-tiered pricing
    -    `tiered6` - Six-tiered pricing
    -    `flatRate` - Flat rate pricing
    -    `consumerChoice` - ConsumerChoice
    -    `rewardPayChoice` - RewardPayChoice
    """

    plan_type: typing_extensions.Annotated[
        typing.Literal["tiered4"], FieldMetadata(alias="planType"), pydantic.Field(alias="planType")
    ] = "tiered4"
    fees: Tiered4Fees

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PricingAgreementUs50ProcessorCard_Tiered6(UniversalBaseModel):
    """
    Polymorphic object that contains fees for card transactions.

    The value of the planType field determines which variant you should use:
    -    `interchangePlus` - Interchange + pricing
    -    `interchangePlusPlus` - Interchange pricing with three tiers
    -    `tiered3` - Three-tiered pricing
    -    `tiered4` - Four-tiered pricing
    -    `tiered6` - Six-tiered pricing
    -    `flatRate` - Flat rate pricing
    -    `consumerChoice` - ConsumerChoice
    -    `rewardPayChoice` - RewardPayChoice
    """

    plan_type: typing_extensions.Annotated[
        typing.Literal["tiered6"], FieldMetadata(alias="planType"), pydantic.Field(alias="planType")
    ] = "tiered6"
    fees: Tiered6Fees

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PricingAgreementUs50ProcessorCard_FlatRate(UniversalBaseModel):
    """
    Polymorphic object that contains fees for card transactions.

    The value of the planType field determines which variant you should use:
    -    `interchangePlus` - Interchange + pricing
    -    `interchangePlusPlus` - Interchange pricing with three tiers
    -    `tiered3` - Three-tiered pricing
    -    `tiered4` - Four-tiered pricing
    -    `tiered6` - Six-tiered pricing
    -    `flatRate` - Flat rate pricing
    -    `consumerChoice` - ConsumerChoice
    -    `rewardPayChoice` - RewardPayChoice
    """

    plan_type: typing_extensions.Annotated[
        typing.Literal["flatRate"], FieldMetadata(alias="planType"), pydantic.Field(alias="planType")
    ] = "flatRate"
    fees: FlatRateFees

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PricingAgreementUs50ProcessorCard_ConsumerChoice(UniversalBaseModel):
    """
    Polymorphic object that contains fees for card transactions.

    The value of the planType field determines which variant you should use:
    -    `interchangePlus` - Interchange + pricing
    -    `interchangePlusPlus` - Interchange pricing with three tiers
    -    `tiered3` - Three-tiered pricing
    -    `tiered4` - Four-tiered pricing
    -    `tiered6` - Six-tiered pricing
    -    `flatRate` - Flat rate pricing
    -    `consumerChoice` - ConsumerChoice
    -    `rewardPayChoice` - RewardPayChoice
    """

    plan_type: typing_extensions.Annotated[
        typing.Literal["consumerChoice"], FieldMetadata(alias="planType"), pydantic.Field(alias="planType")
    ] = "consumerChoice"
    fees: ConsumerChoiceFees

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class PricingAgreementUs50ProcessorCard_RewardPayChoice(UniversalBaseModel):
    """
    Polymorphic object that contains fees for card transactions.

    The value of the planType field determines which variant you should use:
    -    `interchangePlus` - Interchange + pricing
    -    `interchangePlusPlus` - Interchange pricing with three tiers
    -    `tiered3` - Three-tiered pricing
    -    `tiered4` - Four-tiered pricing
    -    `tiered6` - Six-tiered pricing
    -    `flatRate` - Flat rate pricing
    -    `consumerChoice` - ConsumerChoice
    -    `rewardPayChoice` - RewardPayChoice
    """

    plan_type: typing_extensions.Annotated[
        typing.Literal["rewardPayChoice"], FieldMetadata(alias="planType"), pydantic.Field(alias="planType")
    ] = "rewardPayChoice"
    fees: RewardPayChoiceFees

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


PricingAgreementUs50ProcessorCard = typing_extensions.Annotated[
    typing.Union[
        PricingAgreementUs50ProcessorCard_InterchangePlus,
        PricingAgreementUs50ProcessorCard_InterchangePlusPlus,
        PricingAgreementUs50ProcessorCard_Tiered3,
        PricingAgreementUs50ProcessorCard_Tiered4,
        PricingAgreementUs50ProcessorCard_Tiered6,
        PricingAgreementUs50ProcessorCard_FlatRate,
        PricingAgreementUs50ProcessorCard_ConsumerChoice,
        PricingAgreementUs50ProcessorCard_RewardPayChoice,
    ],
    pydantic.Field(discriminator="plan_type"),
]
