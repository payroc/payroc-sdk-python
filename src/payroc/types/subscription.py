# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from ..core.serialization import FieldMetadata
from .currency import Currency
from .custom_field import CustomField
from .payment_plan_summary import PaymentPlanSummary
from .secure_token_summary import SecureTokenSummary
from .subscription_frequency import SubscriptionFrequency
from .subscription_payment_order import SubscriptionPaymentOrder
from .subscription_recurring_order import SubscriptionRecurringOrder
from .subscription_state import SubscriptionState
from .subscription_type import SubscriptionType


class Subscription(UniversalBaseModel):
    subscription_id: typing_extensions.Annotated[str, FieldMetadata(alias="subscriptionId")] = pydantic.Field()
    """
    Unique identifier that the merchant assigned to the subscription.
    """

    processing_terminal_id: typing_extensions.Annotated[str, FieldMetadata(alias="processingTerminalId")] = (
        pydantic.Field()
    )
    """
    Unique identifier of the terminal that the subscription is linked to.
    """

    payment_plan: typing_extensions.Annotated[PaymentPlanSummary, FieldMetadata(alias="paymentPlan")]
    secure_token: typing_extensions.Annotated[SecureTokenSummary, FieldMetadata(alias="secureToken")]
    name: str = pydantic.Field()
    """
    Name of the subscription.
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    Description of the subscription.
    """

    currency: Currency
    setup_order: typing_extensions.Annotated[
        typing.Optional[SubscriptionPaymentOrder], FieldMetadata(alias="setupOrder")
    ] = None
    recurring_order: typing_extensions.Annotated[
        typing.Optional[SubscriptionRecurringOrder], FieldMetadata(alias="recurringOrder")
    ] = None
    current_state: typing_extensions.Annotated[SubscriptionState, FieldMetadata(alias="currentState")]
    start_date: typing_extensions.Annotated[dt.date, FieldMetadata(alias="startDate")] = pydantic.Field()
    """
    Format: **YYYY-MM-DD**  
    Subscription's start date.
    """

    end_date: typing_extensions.Annotated[typing.Optional[dt.date], FieldMetadata(alias="endDate")] = pydantic.Field(
        default=None
    )
    """
    Format: **YYYY-MM-DD** 
    Subscription's end date.  
    **Note:** If you provide values for both **length** and **endDate**, 
    our gateway uses the value for **endDate** to determine when the subscription should end. 
    """

    length: typing.Optional[int] = pydantic.Field(default=None)
    """
    Total number of billing cycles. To indicate that the subscription should run indefinitely, send a value of `0`. This value replaces the **length** inherited from the payment plan.  
    **Note:** If you provide values for both **length** and **endDate**, our gateway uses the value for **endDate** to determine when the subscription should end.
    """

    type: SubscriptionType = pydantic.Field()
    """
    How the merchant takes the payment from the customer’s account.  
    - `manual` – The merchant manually collects payments from the customer.  
    - `automatic` – The terminal automatically collects payments from the customer.
    """

    frequency: SubscriptionFrequency = pydantic.Field()
    """
    Indicates how often the merchant or the terminal collects a payment from the customer.
    """

    pause_collection_for: typing_extensions.Annotated[
        typing.Optional[int], FieldMetadata(alias="pauseCollectionFor")
    ] = pydantic.Field(default=None)
    """
    Number of billing cycles that the merchant wants to pause payments for. 
    For example, if the merchant wants to offer a free trial period.
    """

    custom_fields: typing_extensions.Annotated[
        typing.Optional[typing.List[CustomField]], FieldMetadata(alias="customFields")
    ] = pydantic.Field(default=None)
    """
    Array of customField objects.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
