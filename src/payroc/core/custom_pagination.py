# This file was auto-generated by Fern from our API Definition.

"""
Custom Pagination Support

This file is designed to be modified by SDK users to implement their own
pagination logic. The generator will import SyncPayrocPager and AsyncPayrocPager
from this module when custom pagination is used.

Users should:
1. Implement their custom pager (e.g., PayrocPager, MyPayrocPager, etc.)
2. Create adapter classes (SyncPayrocPager/AsyncPayrocPager) that bridge
   between the generated SDK code and their custom pager implementation
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from typing import Any, AsyncIterator, Generic, Iterator, List, Optional, TypeVar, cast

# Import the base utilities you'll need
# Adjust these imports based on your actual structure
try:
    from .client_wrapper import AsyncClientWrapper, SyncClientWrapper
except ImportError:
    # Fallback for type hints
    AsyncClientWrapper = Any  # type: ignore
    SyncClientWrapper = Any  # type: ignore

TItem = TypeVar("TItem")
TResponse = TypeVar("TResponse")


class _ParsedResponse(Generic[TItem]):
    """Internal class to hold parsed pagination response data."""

    def __init__(self, data: List[TItem], links: List[Any]):
        self.data = data
        self.links = links


@dataclass
class Page(Generic[TItem]):
    """Represents a single page of results."""

    items: List[TItem]

    def __iter__(self) -> Iterator[TItem]:
        return iter(self.items)

    def __len__(self) -> int:
        return len(self.items)

    @classmethod
    def empty(cls) -> Page[TItem]:
        """Create an empty page."""
        return cls(items=[])


class SyncPayrocPager(Generic[TItem, TResponse]):
    """
    Synchronous pagination implementation for Payroc API.

    This pager supports bidirectional pagination (next and previous pages)
    and provides methods to iterate through items and pages.
    """

    def __init__(
        self,
        *,
        initial_response: TResponse,
        client_wrapper: SyncClientWrapper,
    ):
        """
        Initialize the custom pager.

        Args:
            initial_response: The parsed API response from the first request
            client_wrapper: The client wrapper providing HTTP client and utilities
        """
        self._client_wrapper = client_wrapper
        self._parse_response(initial_response)

    def _parse_response(self, response: TResponse) -> None:
        """Parse a response and update the pager state."""
        # Extract data from response
        data = getattr(response, "data", None)
        if data is None:
            data = []

        self._current_page = Page(items=list(data))

        # Extract links from response
        links = getattr(response, "links", None)
        if links is None:
            links = []

        self._next_url: Optional[str] = None
        self._previous_url: Optional[str] = None

        for link in links:
            if isinstance(link, dict):
                rel = link.get("rel")
                href = link.get("href")
            else:
                rel = getattr(link, "rel", None)
                href = getattr(link, "href", None)

            if rel == "next" and href:
                self._next_url = href
            elif rel == "previous" and href:
                self._previous_url = href

    @property
    def has_next_page(self) -> bool:
        """Check if there is a next page available."""
        return self._next_url is not None

    @property
    def has_previous_page(self) -> bool:
        """Check if there is a previous page available."""
        return self._previous_url is not None

    @property
    def current_page(self) -> Page[TItem]:
        """Get the current page of results."""
        return self._current_page

    def get_next_page(self) -> Page[TItem]:
        """
        Fetch and return the next page of results.

        Returns:
            The next page of results, or an empty page if no next page exists.
        """
        if not self.has_next_page:
            return Page.empty()

        response = self._fetch_page(self._next_url)
        self._parse_response(response)
        return self._current_page

    def get_previous_page(self) -> Page[TItem]:
        """
        Fetch and return the previous page of results.

        Returns:
            The previous page of results, or an empty page if no previous page exists.
        """
        if not self.has_previous_page:
            return Page.empty()

        response = self._fetch_page(self._previous_url)
        self._parse_response(response)
        return self._current_page

    def _fetch_page(self, url: Optional[str]) -> TResponse:
        """Fetch a page from the given URL."""
        if url is None:
            raise ValueError("URL cannot be None")

        http_response = self._client_wrapper.httpx_client.request(
            path=url,
            method="GET",
            base_url="",
        )

        response_json = json.loads(http_response.text)
        data = response_json.get("data", [])
        links = response_json.get("links", [])

        parsed_response = _ParsedResponse(data=data, links=links)
        return cast(TResponse, parsed_response)

    def __iter__(self) -> Iterator[TItem]:
        """Iterate through all items across all pages."""
        for item in self._current_page:
            yield item

        for page in self.get_next_pages():
            for item in page:
                yield item

    def get_next_pages(self) -> Iterator[Page[TItem]]:
        """
        Iterate through all next pages.

        Yields:
            Each subsequent page of results.
        """
        while self.has_next_page:
            yield self.get_next_page()

    def get_previous_pages(self) -> Iterator[Page[TItem]]:
        """
        Iterate through all previous pages.

        Yields:
            Each previous page of results.
        """
        while self.has_previous_page:
            yield self.get_previous_page()


class AsyncPayrocPager(Generic[TItem, TResponse]):
    """
    Asynchronous pagination implementation for Payroc API.

    This pager supports bidirectional pagination (next and previous pages)
    and provides methods to iterate through items and pages.
    """

    def __init__(
        self,
        *,
        initial_response: TResponse,
        client_wrapper: AsyncClientWrapper,
    ):
        """
        Initialize the custom async pager.

        Args:
            initial_response: The parsed API response from the first request
            client_wrapper: The client wrapper providing HTTP client and utilities
        """
        self._client_wrapper = client_wrapper
        self._parse_response(initial_response)

    def _parse_response(self, response: TResponse) -> None:
        """Parse a response and update the pager state."""
        # Extract data from response
        data = getattr(response, "data", None)
        if data is None:
            data = []

        self._current_page = Page(items=list(data))

        # Extract links from response
        links = getattr(response, "links", None)
        if links is None:
            links = []

        self._next_url: Optional[str] = None
        self._previous_url: Optional[str] = None

        for link in links:
            if isinstance(link, dict):
                rel = link.get("rel")
                href = link.get("href")
            else:
                rel = getattr(link, "rel", None)
                href = getattr(link, "href", None)

            if rel == "next" and href:
                self._next_url = href
            elif rel == "previous" and href:
                self._previous_url = href

    @property
    def has_next_page(self) -> bool:
        """Check if there is a next page available."""
        return self._next_url is not None

    @property
    def has_previous_page(self) -> bool:
        """Check if there is a previous page available."""
        return self._previous_url is not None

    @property
    def current_page(self) -> Page[TItem]:
        """Get the current page of results."""
        return self._current_page

    async def get_next_page_async(self) -> Page[TItem]:
        """
        Fetch and return the next page of results.

        Returns:
            The next page of results, or an empty page if no next page exists.
        """
        if not self.has_next_page:
            return Page.empty()

        response = await self._fetch_page(self._next_url)
        self._parse_response(response)
        return self._current_page

    async def get_previous_page_async(self) -> Page[TItem]:
        """
        Fetch and return the previous page of results.

        Returns:
            The previous page of results, or an empty page if no previous page exists.
        """
        if not self.has_previous_page:
            return Page.empty()

        response = await self._fetch_page(self._previous_url)
        self._parse_response(response)
        return self._current_page

    async def _fetch_page(self, url: Optional[str]) -> TResponse:
        """Fetch a page from the given URL."""
        if url is None:
            raise ValueError("URL cannot be None")

        http_response = await self._client_wrapper.httpx_client.request(
            path=url,
            method="GET",
            base_url="",
        )

        response_json = json.loads(http_response.text)
        data = response_json.get("data", [])
        links = response_json.get("links", [])

        parsed_response = _ParsedResponse(data=data, links=links)
        return cast(TResponse, parsed_response)

    async def __aiter__(self) -> AsyncIterator[TItem]:
        """Asynchronously iterate through all items across all pages."""
        for item in self._current_page:
            yield item

        async for page in self.get_next_pages_async():
            for item in page:
                yield item

    async def get_next_pages_async(self) -> AsyncIterator[Page[TItem]]:
        """
        Asynchronously iterate through all next pages.

        Yields:
            Each subsequent page of results.
        """
        while self.has_next_page:
            yield await self.get_next_page_async()

    async def get_previous_pages_async(self) -> AsyncIterator[Page[TItem]]:
        """
        Asynchronously iterate through all previous pages.

        Yields:
            Each previous page of results.
        """
        while self.has_previous_page:
            yield await self.get_previous_page_async()
