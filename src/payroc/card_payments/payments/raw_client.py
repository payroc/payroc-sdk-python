# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.custom_pagination import AsyncPayrocPager, SyncPayrocPager
from ...core.datetime_utils import serialize_datetime
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ...types.custom_field import CustomField
from ...types.customer import Customer
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_fifteen import FourHundredFifteen
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_nine import FourHundredNine
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.ip_address import IpAddress
from ...types.itemized_breakdown_request import ItemizedBreakdownRequest
from ...types.offline_processing import OfflineProcessing
from ...types.payment import Payment
from ...types.payment_order_request import PaymentOrderRequest
from ...types.payment_paginated_list_for_read import PaymentPaginatedListForRead
from ...types.retrieved_payment import RetrievedPayment
from ...types.schemas_credential_on_file import SchemasCredentialOnFile
from .types.list_payments_request_settlement_state import ListPaymentsRequestSettlementState
from .types.list_payments_request_status_item import ListPaymentsRequestStatusItem
from .types.list_payments_request_tender import ListPaymentsRequestTender
from .types.list_payments_request_tip_mode_item import ListPaymentsRequestTipModeItem
from .types.list_payments_request_type_item import ListPaymentsRequestTypeItem
from .types.payment_adjustment_adjustments_item import PaymentAdjustmentAdjustmentsItem
from .types.payment_request_channel import PaymentRequestChannel
from .types.payment_request_payment_method import PaymentRequestPaymentMethod
from .types.payment_request_three_d_secure import PaymentRequestThreeDSecure

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawPaymentsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        processing_terminal_id: typing.Optional[str] = None,
        order_id: typing.Optional[str] = None,
        operator: typing.Optional[str] = None,
        cardholder_name: typing.Optional[str] = None,
        first_6: typing.Optional[str] = None,
        last_4: typing.Optional[str] = None,
        tender: typing.Optional[ListPaymentsRequestTender] = None,
        tip_mode: typing.Optional[
            typing.Union[ListPaymentsRequestTipModeItem, typing.Sequence[ListPaymentsRequestTipModeItem]]
        ] = None,
        type: typing.Optional[
            typing.Union[ListPaymentsRequestTypeItem, typing.Sequence[ListPaymentsRequestTypeItem]]
        ] = None,
        status: typing.Optional[
            typing.Union[ListPaymentsRequestStatusItem, typing.Sequence[ListPaymentsRequestStatusItem]]
        ] = None,
        date_from: typing.Optional[dt.datetime] = None,
        date_to: typing.Optional[dt.datetime] = None,
        settlement_state: typing.Optional[ListPaymentsRequestSettlementState] = None,
        settlement_date: typing.Optional[dt.date] = None,
        payment_link_id: typing.Optional[str] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[RetrievedPayment, PaymentPaginatedListForRead]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of payments.

        **Note:** If you want to view the details of a specific payment and you have its paymentId, use our [Retrieve Payment](https://docs.payroc.com/api/schema/card-payments/payments/retrieve) method.

        Use query parameters to filter the list of results that we return, for example, to search for payments for a customer, a tip mode, or a date range.

        Our gateway returns the following information about each payment in the list:

        - Order details, including the transaction amount and when it was processed.
        - Payment card details, including the masked card number, expiry date, and payment method.
        - Cardholder details, including their contact information and shipping address.
        - Payment details, including the payment type, status, and response.

        For each transaction, we also return the paymentId and an optional secureTokenId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : typing.Optional[str]
            Filter by terminal ID.

        order_id : typing.Optional[str]
            Filter payments by order ID.

        operator : typing.Optional[str]
            Filter payments by operator.

        cardholder_name : typing.Optional[str]
            Filter payments by the cardholder’s name.

        first_6 : typing.Optional[str]
            Filter payments by the first six digits of the card number that the customer used in the transaction.

        last_4 : typing.Optional[str]
            Filter payments by the last four digits of the card number that the customer used in the transaction.

        tender : typing.Optional[ListPaymentsRequestTender]
            Filter by tender type.

        tip_mode : typing.Optional[typing.Union[ListPaymentsRequestTipModeItem, typing.Sequence[ListPaymentsRequestTipModeItem]]]
            Filter payments by tip.

        type : typing.Optional[typing.Union[ListPaymentsRequestTypeItem, typing.Sequence[ListPaymentsRequestTypeItem]]]
            Filter payments by transaction type.

        status : typing.Optional[typing.Union[ListPaymentsRequestStatusItem, typing.Sequence[ListPaymentsRequestStatusItem]]]
            Filter payments by the status of the transaction.

        date_from : typing.Optional[dt.datetime]
            Filter by payments that the processor processed after a specific date. The date format follows the ISO 8601 standard.

        date_to : typing.Optional[dt.datetime]
            Filter by payments that the processer processed before a specific date. The date format follows the ISO 8601 standard.

        settlement_state : typing.Optional[ListPaymentsRequestSettlementState]
            Filter payments by the settlement status of the transaction.

        settlement_date : typing.Optional[dt.date]
            Filter by payments that the processor settled on a specific date in the format **YYYY-MM-DD**.

        payment_link_id : typing.Optional[str]
            Unique identifier that our gateway assigned to the payment link.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[RetrievedPayment, PaymentPaginatedListForRead]
            Successful request. Returns a list of payments.
        """
        _response = self._client_wrapper.httpx_client.request(
            "payments",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "processingTerminalId": processing_terminal_id,
                "orderId": order_id,
                "operator": operator,
                "cardholderName": cardholder_name,
                "first6": first_6,
                "last4": last_4,
                "tender": tender,
                "tipMode": tip_mode,
                "type": type,
                "status": status,
                "dateFrom": serialize_datetime(date_from) if date_from is not None else None,
                "dateTo": serialize_datetime(date_to) if date_to is not None else None,
                "settlementState": settlement_state,
                "settlementDate": str(settlement_date) if settlement_date is not None else None,
                "paymentLinkId": payment_link_id,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaymentPaginatedListForRead,
                    parse_obj_as(
                        type_=PaymentPaginatedListForRead,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        idempotency_key: str,
        channel: PaymentRequestChannel,
        processing_terminal_id: str,
        order: PaymentOrderRequest,
        payment_method: PaymentRequestPaymentMethod,
        operator: typing.Optional[str] = OMIT,
        customer: typing.Optional[Customer] = OMIT,
        ip_address: typing.Optional[IpAddress] = OMIT,
        three_d_secure: typing.Optional[PaymentRequestThreeDSecure] = OMIT,
        credential_on_file: typing.Optional[SchemasCredentialOnFile] = OMIT,
        offline_processing: typing.Optional[OfflineProcessing] = OMIT,
        auto_capture: typing.Optional[bool] = OMIT,
        process_as_sale: typing.Optional[bool] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Payment]:
        """
        Use this method to run a sale or a pre-authorization with a customer's payment card.

        In the response, our gateway returns information about the card payment and a paymentId, which you need for the following methods:

        -    [Retrieve payment](https://docs.payroc.com/api/schema/card-payments/payments/retrieve) - View the details of the card payment.
        -    [Adjust payment](https://docs.payroc.com/api/schema/card-payments/payments/adjust) - Update the details of the card payment.
        -    [Capture payment](https://docs.payroc.com/api/schema/card-payments/payments/capture)  - Capture the pre-authorization.
        -    [Reverse payment](https://docs.payroc.com/api/schema/card-payments/refunds/reverse)  - Cancel the card payment if it's in an open batch.
        -    [Refund payment](https://docs.payroc.com/api/schema/card-payments/refunds/create-referenced-refund)  - Run a referenced refund to return funds to the payment card.

        **Payment methods**

        - **Cards** - Credit, debit, and EBT
        - **Digital wallets** - [Apple Pay®](https://docs.payroc.com/guides/take-payments/apple-pay) and [Google Pay®](https://docs.payroc.com/guides/take-payments/google-pay)
        - **Tokens** - Secure tokens and single-use tokens

        **Features**

        Our Create Payment method also supports the following features:

        - [Repeat payments](https://docs.payroc.com/guides/take-payments/repeat-payments/use-your-own-software) - Run multiple payments as part of a payment schedule that you manage with your own software.
        - **Offline sales** - Run a sale or a pre-authorization if the terminal loses its connection to our gateway.
        - [Tokenization](https://docs.payroc.com/guides/take-payments/save-payment-details) - Save card details to use in future transactions.
        - [3-D Secure](https://docs.payroc.com/guides/take-payments/3-d-secure) - Verify the identity of the cardholder.
        - [Custom fields](https://docs.payroc.com/guides/take-payments/add-custom-fields) - Add your own data to a payment.
        - **Tips** - Add tips to the card payment.
        - **Taxes** - Add local taxes to the card payment.
        - **Surcharging** - Add a surcharge to the card payment.
        - **Dual pricing** - Offer different prices based on payment method, for example, if you use our RewardPay Choice pricing program.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        channel : PaymentRequestChannel
            Channel that the merchant used to receive the payment details.

        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        order : PaymentOrderRequest

        payment_method : PaymentRequestPaymentMethod
            Polymorphic object that contains payment details.

            The value of the type parameter determines which variant you should use:
            -    `card` - Payment card details
            -    `secureToken` - Secure token details
            -    `digitalWallet` - Digital wallet details
            -    `singleUseToken` - Single-use token details

        operator : typing.Optional[str]
            Operator who ran the transaction.

        customer : typing.Optional[Customer]

        ip_address : typing.Optional[IpAddress]

        three_d_secure : typing.Optional[PaymentRequestThreeDSecure]
            Polymorphic object that contains authentication information from 3-D Secure.

            The value of the serviceProvider parameter determines which variant you should use:
            -    `gateway` - Use our gateway to run a 3-D Secure check.
            -    `thirdParty` - Use a third party to run a 3-D Secure check.

        credential_on_file : typing.Optional[SchemasCredentialOnFile]

        offline_processing : typing.Optional[OfflineProcessing]

        auto_capture : typing.Optional[bool]
            Indicates if we should automatically capture the payment amount.

            - `true` - Run a sale and automatically capture the transaction.
            - `false`- Run a pre-authorization and capture the transaction later.

            **Note:** If you send `false` and the terminal doesn't support pre-authorization, we set the transaction's status to pending. The merchant must capture the transaction to take payment from the customer.

        process_as_sale : typing.Optional[bool]
            Indicates if we should immediately settle the sale transaction. The merchant cannot adjust the transaction if we immediately settle it.
            **Note:** If the value for **processAsSale** is `true`, the gateway ignores the value in **autoCapture**.

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Payment]
            Successful request. We processed the transaction.
        """
        _response = self._client_wrapper.httpx_client.request(
            "payments",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "channel": channel,
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=PaymentOrderRequest, direction="write"
                ),
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=Customer, direction="write"
                ),
                "ipAddress": convert_and_respect_annotation_metadata(
                    object_=ip_address, annotation=IpAddress, direction="write"
                ),
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=PaymentRequestPaymentMethod, direction="write"
                ),
                "threeDSecure": convert_and_respect_annotation_metadata(
                    object_=three_d_secure, annotation=PaymentRequestThreeDSecure, direction="write"
                ),
                "credentialOnFile": convert_and_respect_annotation_metadata(
                    object_=credential_on_file, annotation=SchemasCredentialOnFile, direction="write"
                ),
                "offlineProcessing": convert_and_respect_annotation_metadata(
                    object_=offline_processing, annotation=OfflineProcessing, direction="write"
                ),
                "autoCapture": auto_capture,
                "processAsSale": process_as_sale,
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Payment,
                    parse_obj_as(
                        type_=Payment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self, payment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[RetrievedPayment]:
        """
        Use this method to retrieve information about a card payment.

        To retrieve a payment, you need its paymentId. Our gateway returned the paymentId in the response of the [Create Payment](https://docs.payroc.com/api/schema/card-payments/payments/create) method.

        **Note:** If you don't have the paymentId, use our [List Payments](https://docs.payroc.com/api/schema/card-payments/payments/list) method to search for the payment.

        Our gateway returns the following information about the payment:

        - Order details, including the transaction amount and when it was processed.
        - Payment card details, including the masked card number, expiry date, and payment method.
        - Cardholder details, including their contact information and shipping address.
        - Payment details, including the payment type, status, and response.

        If the merchant saved the customer's card details, our gateway returns a secureTokenID, which you can use to perform follow-on actions.

        Parameters
        ----------
        payment_id : str
            Unique identifier of the payment that the merchant wants to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RetrievedPayment]
            Successful request. Returns the payment.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"payments/{jsonable_encoder(payment_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrievedPayment,
                    parse_obj_as(
                        type_=RetrievedPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def adjust(
        self,
        payment_id: str,
        *,
        idempotency_key: str,
        adjustments: typing.Sequence[PaymentAdjustmentAdjustmentsItem],
        operator: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Payment]:
        """
        Use this method to adjust a payment in an open batch.

        To adjust a payment, you need its paymentId. Our gateway returned the paymentId in the response of the [Create Payment](https://docs.payroc.com/api/schema/card-payments/payments/create) method.

        **Note:** If you don't have the paymentId, use our [List Payments](https://docs.payroc.com/api/schema/card-payments/payments/list) method to search for the payment.

        You can adjust the following details of the payment:
        - Sale amount and tip amount
        - Payment status
        - Cardholder shipping address and contact information
        - Cardholder signature data

        Our gateway returns information about the adjusted payment, including information about the payment card and the cardholder.

        Parameters
        ----------
        payment_id : str
            Unique identifier of the payment that the merchant wants to retrieve.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        adjustments : typing.Sequence[PaymentAdjustmentAdjustmentsItem]
            Array of polymorphic objects which contain information about adjustments to a payment.

            The value of the type parameter determines which variant you should use:
            -    `order` - Tip information.
            -    `status` - Status of the transaction.
            -    `customer` - Customer's contact information and shipping address.
            -    `signature` - Customer's signature.

        operator : typing.Optional[str]
            Operator who adjusted the payment.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Payment]
            Successful request. We adjusted the transaction.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"payments/{jsonable_encoder(payment_id)}/adjust",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "operator": operator,
                "adjustments": convert_and_respect_annotation_metadata(
                    object_=adjustments, annotation=typing.Sequence[PaymentAdjustmentAdjustmentsItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Payment,
                    parse_obj_as(
                        type_=Payment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def capture(
        self,
        payment_id: str,
        *,
        idempotency_key: str,
        processing_terminal_id: typing.Optional[str] = OMIT,
        operator: typing.Optional[str] = OMIT,
        amount: typing.Optional[int] = OMIT,
        breakdown: typing.Optional[ItemizedBreakdownRequest] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Payment]:
        """
        Use this method to capture a pre-authorization.

        To capture a pre-authorization, you need its paymentId. Our gateway returned the paymentId in the response of the [Create Payment](https://docs.payroc.com/api/schema/card-payments/payments/create) method.

        **Note:** If you don't have the paymentId, use our [List Payments](https://docs.payroc.com/api/schema/card-payments/payments/list) method to search for the payment.

        Depending on the amount you want to capture, complete the following:
        -    **Capture the full amount of the pre-authorization** - Don't send a value for the amount parameter in your request.
        -    **Capture less than the amount of the pre-authorization** - Send a value for the amount parameter in your request.
        -    **Capture more than the amount of the pre-authorization** - Adjust the pre-authorization before you capture it. For more information about adjusting a pre-authorization, go to [Adjust Payment](https://docs.payroc.com/api/schema/card-payments/payments/adjust).

        If your request is successful, our gateway takes the amount from the payment card.

        **Note:** For more information about pre-authorizations and captures, go to [Run a pre-authorization](https://docs.payroc.com/guides/integrate/run-a-pre-authorization).

        Parameters
        ----------
        payment_id : str
            Unique identifier of the payment that the merchant wants to retrieve.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        processing_terminal_id : typing.Optional[str]
            Unique identifier that our gateway assigned to the terminal.

        operator : typing.Optional[str]
            Operator who captured the payment.

        amount : typing.Optional[int]
            Amount that the merchant wants to capture. The value is in the currency's lowest denomination, for example, cents.
            **Note:** If the merchant does not send an amount, we capture the total amount of the transaction.

        breakdown : typing.Optional[ItemizedBreakdownRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Payment]
            Successful request. We captured the payment.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"payments/{jsonable_encoder(payment_id)}/capture",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "amount": amount,
                "breakdown": convert_and_respect_annotation_metadata(
                    object_=breakdown, annotation=ItemizedBreakdownRequest, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Payment,
                    parse_obj_as(
                        type_=Payment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawPaymentsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        processing_terminal_id: typing.Optional[str] = None,
        order_id: typing.Optional[str] = None,
        operator: typing.Optional[str] = None,
        cardholder_name: typing.Optional[str] = None,
        first_6: typing.Optional[str] = None,
        last_4: typing.Optional[str] = None,
        tender: typing.Optional[ListPaymentsRequestTender] = None,
        tip_mode: typing.Optional[
            typing.Union[ListPaymentsRequestTipModeItem, typing.Sequence[ListPaymentsRequestTipModeItem]]
        ] = None,
        type: typing.Optional[
            typing.Union[ListPaymentsRequestTypeItem, typing.Sequence[ListPaymentsRequestTypeItem]]
        ] = None,
        status: typing.Optional[
            typing.Union[ListPaymentsRequestStatusItem, typing.Sequence[ListPaymentsRequestStatusItem]]
        ] = None,
        date_from: typing.Optional[dt.datetime] = None,
        date_to: typing.Optional[dt.datetime] = None,
        settlement_state: typing.Optional[ListPaymentsRequestSettlementState] = None,
        settlement_date: typing.Optional[dt.date] = None,
        payment_link_id: typing.Optional[str] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[RetrievedPayment, PaymentPaginatedListForRead]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of payments.

        **Note:** If you want to view the details of a specific payment and you have its paymentId, use our [Retrieve Payment](https://docs.payroc.com/api/schema/card-payments/payments/retrieve) method.

        Use query parameters to filter the list of results that we return, for example, to search for payments for a customer, a tip mode, or a date range.

        Our gateway returns the following information about each payment in the list:

        - Order details, including the transaction amount and when it was processed.
        - Payment card details, including the masked card number, expiry date, and payment method.
        - Cardholder details, including their contact information and shipping address.
        - Payment details, including the payment type, status, and response.

        For each transaction, we also return the paymentId and an optional secureTokenId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : typing.Optional[str]
            Filter by terminal ID.

        order_id : typing.Optional[str]
            Filter payments by order ID.

        operator : typing.Optional[str]
            Filter payments by operator.

        cardholder_name : typing.Optional[str]
            Filter payments by the cardholder’s name.

        first_6 : typing.Optional[str]
            Filter payments by the first six digits of the card number that the customer used in the transaction.

        last_4 : typing.Optional[str]
            Filter payments by the last four digits of the card number that the customer used in the transaction.

        tender : typing.Optional[ListPaymentsRequestTender]
            Filter by tender type.

        tip_mode : typing.Optional[typing.Union[ListPaymentsRequestTipModeItem, typing.Sequence[ListPaymentsRequestTipModeItem]]]
            Filter payments by tip.

        type : typing.Optional[typing.Union[ListPaymentsRequestTypeItem, typing.Sequence[ListPaymentsRequestTypeItem]]]
            Filter payments by transaction type.

        status : typing.Optional[typing.Union[ListPaymentsRequestStatusItem, typing.Sequence[ListPaymentsRequestStatusItem]]]
            Filter payments by the status of the transaction.

        date_from : typing.Optional[dt.datetime]
            Filter by payments that the processor processed after a specific date. The date format follows the ISO 8601 standard.

        date_to : typing.Optional[dt.datetime]
            Filter by payments that the processer processed before a specific date. The date format follows the ISO 8601 standard.

        settlement_state : typing.Optional[ListPaymentsRequestSettlementState]
            Filter payments by the settlement status of the transaction.

        settlement_date : typing.Optional[dt.date]
            Filter by payments that the processor settled on a specific date in the format **YYYY-MM-DD**.

        payment_link_id : typing.Optional[str]
            Unique identifier that our gateway assigned to the payment link.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[RetrievedPayment, PaymentPaginatedListForRead]
            Successful request. Returns a list of payments.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "payments",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "processingTerminalId": processing_terminal_id,
                "orderId": order_id,
                "operator": operator,
                "cardholderName": cardholder_name,
                "first6": first_6,
                "last4": last_4,
                "tender": tender,
                "tipMode": tip_mode,
                "type": type,
                "status": status,
                "dateFrom": serialize_datetime(date_from) if date_from is not None else None,
                "dateTo": serialize_datetime(date_to) if date_to is not None else None,
                "settlementState": settlement_state,
                "settlementDate": str(settlement_date) if settlement_date is not None else None,
                "paymentLinkId": payment_link_id,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaymentPaginatedListForRead,
                    parse_obj_as(
                        type_=PaymentPaginatedListForRead,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        idempotency_key: str,
        channel: PaymentRequestChannel,
        processing_terminal_id: str,
        order: PaymentOrderRequest,
        payment_method: PaymentRequestPaymentMethod,
        operator: typing.Optional[str] = OMIT,
        customer: typing.Optional[Customer] = OMIT,
        ip_address: typing.Optional[IpAddress] = OMIT,
        three_d_secure: typing.Optional[PaymentRequestThreeDSecure] = OMIT,
        credential_on_file: typing.Optional[SchemasCredentialOnFile] = OMIT,
        offline_processing: typing.Optional[OfflineProcessing] = OMIT,
        auto_capture: typing.Optional[bool] = OMIT,
        process_as_sale: typing.Optional[bool] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Payment]:
        """
        Use this method to run a sale or a pre-authorization with a customer's payment card.

        In the response, our gateway returns information about the card payment and a paymentId, which you need for the following methods:

        -    [Retrieve payment](https://docs.payroc.com/api/schema/card-payments/payments/retrieve) - View the details of the card payment.
        -    [Adjust payment](https://docs.payroc.com/api/schema/card-payments/payments/adjust) - Update the details of the card payment.
        -    [Capture payment](https://docs.payroc.com/api/schema/card-payments/payments/capture)  - Capture the pre-authorization.
        -    [Reverse payment](https://docs.payroc.com/api/schema/card-payments/refunds/reverse)  - Cancel the card payment if it's in an open batch.
        -    [Refund payment](https://docs.payroc.com/api/schema/card-payments/refunds/create-referenced-refund)  - Run a referenced refund to return funds to the payment card.

        **Payment methods**

        - **Cards** - Credit, debit, and EBT
        - **Digital wallets** - [Apple Pay®](https://docs.payroc.com/guides/take-payments/apple-pay) and [Google Pay®](https://docs.payroc.com/guides/take-payments/google-pay)
        - **Tokens** - Secure tokens and single-use tokens

        **Features**

        Our Create Payment method also supports the following features:

        - [Repeat payments](https://docs.payroc.com/guides/take-payments/repeat-payments/use-your-own-software) - Run multiple payments as part of a payment schedule that you manage with your own software.
        - **Offline sales** - Run a sale or a pre-authorization if the terminal loses its connection to our gateway.
        - [Tokenization](https://docs.payroc.com/guides/take-payments/save-payment-details) - Save card details to use in future transactions.
        - [3-D Secure](https://docs.payroc.com/guides/take-payments/3-d-secure) - Verify the identity of the cardholder.
        - [Custom fields](https://docs.payroc.com/guides/take-payments/add-custom-fields) - Add your own data to a payment.
        - **Tips** - Add tips to the card payment.
        - **Taxes** - Add local taxes to the card payment.
        - **Surcharging** - Add a surcharge to the card payment.
        - **Dual pricing** - Offer different prices based on payment method, for example, if you use our RewardPay Choice pricing program.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        channel : PaymentRequestChannel
            Channel that the merchant used to receive the payment details.

        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        order : PaymentOrderRequest

        payment_method : PaymentRequestPaymentMethod
            Polymorphic object that contains payment details.

            The value of the type parameter determines which variant you should use:
            -    `card` - Payment card details
            -    `secureToken` - Secure token details
            -    `digitalWallet` - Digital wallet details
            -    `singleUseToken` - Single-use token details

        operator : typing.Optional[str]
            Operator who ran the transaction.

        customer : typing.Optional[Customer]

        ip_address : typing.Optional[IpAddress]

        three_d_secure : typing.Optional[PaymentRequestThreeDSecure]
            Polymorphic object that contains authentication information from 3-D Secure.

            The value of the serviceProvider parameter determines which variant you should use:
            -    `gateway` - Use our gateway to run a 3-D Secure check.
            -    `thirdParty` - Use a third party to run a 3-D Secure check.

        credential_on_file : typing.Optional[SchemasCredentialOnFile]

        offline_processing : typing.Optional[OfflineProcessing]

        auto_capture : typing.Optional[bool]
            Indicates if we should automatically capture the payment amount.

            - `true` - Run a sale and automatically capture the transaction.
            - `false`- Run a pre-authorization and capture the transaction later.

            **Note:** If you send `false` and the terminal doesn't support pre-authorization, we set the transaction's status to pending. The merchant must capture the transaction to take payment from the customer.

        process_as_sale : typing.Optional[bool]
            Indicates if we should immediately settle the sale transaction. The merchant cannot adjust the transaction if we immediately settle it.
            **Note:** If the value for **processAsSale** is `true`, the gateway ignores the value in **autoCapture**.

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Payment]
            Successful request. We processed the transaction.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "payments",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "channel": channel,
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=PaymentOrderRequest, direction="write"
                ),
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=Customer, direction="write"
                ),
                "ipAddress": convert_and_respect_annotation_metadata(
                    object_=ip_address, annotation=IpAddress, direction="write"
                ),
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=PaymentRequestPaymentMethod, direction="write"
                ),
                "threeDSecure": convert_and_respect_annotation_metadata(
                    object_=three_d_secure, annotation=PaymentRequestThreeDSecure, direction="write"
                ),
                "credentialOnFile": convert_and_respect_annotation_metadata(
                    object_=credential_on_file, annotation=SchemasCredentialOnFile, direction="write"
                ),
                "offlineProcessing": convert_and_respect_annotation_metadata(
                    object_=offline_processing, annotation=OfflineProcessing, direction="write"
                ),
                "autoCapture": auto_capture,
                "processAsSale": process_as_sale,
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Payment,
                    parse_obj_as(
                        type_=Payment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self, payment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[RetrievedPayment]:
        """
        Use this method to retrieve information about a card payment.

        To retrieve a payment, you need its paymentId. Our gateway returned the paymentId in the response of the [Create Payment](https://docs.payroc.com/api/schema/card-payments/payments/create) method.

        **Note:** If you don't have the paymentId, use our [List Payments](https://docs.payroc.com/api/schema/card-payments/payments/list) method to search for the payment.

        Our gateway returns the following information about the payment:

        - Order details, including the transaction amount and when it was processed.
        - Payment card details, including the masked card number, expiry date, and payment method.
        - Cardholder details, including their contact information and shipping address.
        - Payment details, including the payment type, status, and response.

        If the merchant saved the customer's card details, our gateway returns a secureTokenID, which you can use to perform follow-on actions.

        Parameters
        ----------
        payment_id : str
            Unique identifier of the payment that the merchant wants to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RetrievedPayment]
            Successful request. Returns the payment.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"payments/{jsonable_encoder(payment_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrievedPayment,
                    parse_obj_as(
                        type_=RetrievedPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def adjust(
        self,
        payment_id: str,
        *,
        idempotency_key: str,
        adjustments: typing.Sequence[PaymentAdjustmentAdjustmentsItem],
        operator: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Payment]:
        """
        Use this method to adjust a payment in an open batch.

        To adjust a payment, you need its paymentId. Our gateway returned the paymentId in the response of the [Create Payment](https://docs.payroc.com/api/schema/card-payments/payments/create) method.

        **Note:** If you don't have the paymentId, use our [List Payments](https://docs.payroc.com/api/schema/card-payments/payments/list) method to search for the payment.

        You can adjust the following details of the payment:
        - Sale amount and tip amount
        - Payment status
        - Cardholder shipping address and contact information
        - Cardholder signature data

        Our gateway returns information about the adjusted payment, including information about the payment card and the cardholder.

        Parameters
        ----------
        payment_id : str
            Unique identifier of the payment that the merchant wants to retrieve.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        adjustments : typing.Sequence[PaymentAdjustmentAdjustmentsItem]
            Array of polymorphic objects which contain information about adjustments to a payment.

            The value of the type parameter determines which variant you should use:
            -    `order` - Tip information.
            -    `status` - Status of the transaction.
            -    `customer` - Customer's contact information and shipping address.
            -    `signature` - Customer's signature.

        operator : typing.Optional[str]
            Operator who adjusted the payment.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Payment]
            Successful request. We adjusted the transaction.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"payments/{jsonable_encoder(payment_id)}/adjust",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "operator": operator,
                "adjustments": convert_and_respect_annotation_metadata(
                    object_=adjustments, annotation=typing.Sequence[PaymentAdjustmentAdjustmentsItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Payment,
                    parse_obj_as(
                        type_=Payment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def capture(
        self,
        payment_id: str,
        *,
        idempotency_key: str,
        processing_terminal_id: typing.Optional[str] = OMIT,
        operator: typing.Optional[str] = OMIT,
        amount: typing.Optional[int] = OMIT,
        breakdown: typing.Optional[ItemizedBreakdownRequest] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Payment]:
        """
        Use this method to capture a pre-authorization.

        To capture a pre-authorization, you need its paymentId. Our gateway returned the paymentId in the response of the [Create Payment](https://docs.payroc.com/api/schema/card-payments/payments/create) method.

        **Note:** If you don't have the paymentId, use our [List Payments](https://docs.payroc.com/api/schema/card-payments/payments/list) method to search for the payment.

        Depending on the amount you want to capture, complete the following:
        -    **Capture the full amount of the pre-authorization** - Don't send a value for the amount parameter in your request.
        -    **Capture less than the amount of the pre-authorization** - Send a value for the amount parameter in your request.
        -    **Capture more than the amount of the pre-authorization** - Adjust the pre-authorization before you capture it. For more information about adjusting a pre-authorization, go to [Adjust Payment](https://docs.payroc.com/api/schema/card-payments/payments/adjust).

        If your request is successful, our gateway takes the amount from the payment card.

        **Note:** For more information about pre-authorizations and captures, go to [Run a pre-authorization](https://docs.payroc.com/guides/integrate/run-a-pre-authorization).

        Parameters
        ----------
        payment_id : str
            Unique identifier of the payment that the merchant wants to retrieve.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        processing_terminal_id : typing.Optional[str]
            Unique identifier that our gateway assigned to the terminal.

        operator : typing.Optional[str]
            Operator who captured the payment.

        amount : typing.Optional[int]
            Amount that the merchant wants to capture. The value is in the currency's lowest denomination, for example, cents.
            **Note:** If the merchant does not send an amount, we capture the total amount of the transaction.

        breakdown : typing.Optional[ItemizedBreakdownRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Payment]
            Successful request. We captured the payment.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"payments/{jsonable_encoder(payment_id)}/capture",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "amount": amount,
                "breakdown": convert_and_respect_annotation_metadata(
                    object_=breakdown, annotation=ItemizedBreakdownRequest, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Payment,
                    parse_obj_as(
                        type_=Payment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
