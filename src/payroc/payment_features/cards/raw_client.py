# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ...types.balance import Balance
from ...types.card_info import CardInfo
from ...types.card_verification_result import CardVerificationResult
from ...types.currency import Currency
from ...types.customer import Customer
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_fifteen import FourHundredFifteen
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_nine import FourHundredNine
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.fx_rate import FxRate
from .types.balance_inquiry_card import BalanceInquiryCard
from .types.bin_lookup_card import BinLookupCard
from .types.card_verification_request_card import CardVerificationRequestCard
from .types.fx_rate_inquiry_channel import FxRateInquiryChannel
from .types.fx_rate_inquiry_payment_method import FxRateInquiryPaymentMethod

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawCardsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def verify_card(
        self,
        *,
        idempotency_key: str,
        processing_terminal_id: str,
        card: CardVerificationRequestCard,
        operator: typing.Optional[str] = OMIT,
        customer: typing.Optional[Customer] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CardVerificationResult]:
        """
        Use this method to verify a customer’s card details.

        In the request, send the customer’s card details.

        In the response, our gateway indicates if the card details are valid and if you should use them in follow-on actions.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        card : CardVerificationRequestCard
            Polymorphic object that contains payment details.

        operator : typing.Optional[str]
            Operator who requested to verify the card.

        customer : typing.Optional[Customer]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CardVerificationResult]
            Successful request. Returns the verification status of the card details.
        """
        _response = self._client_wrapper.httpx_client.request(
            "cards/verify",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=Customer, direction="write"
                ),
                "card": convert_and_respect_annotation_metadata(
                    object_=card, annotation=CardVerificationRequestCard, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CardVerificationResult,
                    parse_obj_as(
                        type_=CardVerificationResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def view_ebt_balance(
        self,
        *,
        processing_terminal_id: str,
        currency: Currency,
        card: BalanceInquiryCard,
        operator: typing.Optional[str] = OMIT,
        customer: typing.Optional[Customer] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Balance]:
        """
        Use this method to view the balance of an Electronic Benefit Transfer (EBT) card.

        If the request is successful, our gateway returns the current balance of an EBT card.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        currency : Currency

        card : BalanceInquiryCard
            Polymorphic object that contains payment details.

            The value of the type parameter determines which variant you should use:
            -    `card` - Payment card details
            -    `singleUseToken` - Single-use token details

        operator : typing.Optional[str]
            Operator who requested the balance inquiry.

        customer : typing.Optional[Customer]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Balance]
            Successful request. Returns the current balance of the EBT card.
        """
        _response = self._client_wrapper.httpx_client.request(
            "cards/balance",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "currency": currency,
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=Customer, direction="write"
                ),
                "card": convert_and_respect_annotation_metadata(
                    object_=card, annotation=BalanceInquiryCard, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Balance,
                    parse_obj_as(
                        type_=Balance,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def lookup_bin(
        self,
        *,
        card: BinLookupCard,
        processing_terminal_id: typing.Optional[str] = OMIT,
        amount: typing.Optional[int] = OMIT,
        currency: typing.Optional[Currency] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CardInfo]:
        """
        Use this method to retrieve information about a debit card, a credit card, or an EBT card. If you apply surcharges to transactions, you can also check if the card supports surcharging.

        In the response, our gateway returns the following information about the card:

        - **Card details** - Information about the card, for example, the issuing bank and the masked card number.

        - **Surcharging information** - If you apply a surcharge to transactions, our gateway checks that the card supports surcharging and returns information about the surcharge. For more information about surcharging, go to [Credit card surcharging](https://docs.payroc.com/knowledge/card-payments/credit-card-surcharging).

        Parameters
        ----------
        card : BinLookupCard
            Polymorphic object that contains payment details.

            The value of the type parameter determines which variant you should use:
            -    `card` - Payment card details
            -    `cardBin` - Bank identification number (BIN) of the payment card
            -    `secureToken` - Secure token details
            -    `digitalWallet` - Digital wallet details

        processing_terminal_id : typing.Optional[str]
            Unique identifier that we assigned to the terminal.

        amount : typing.Optional[int]
            Transaction amount that you send to check the surcharge amount. The value is in the currency's lowest denomination, for example, cents.

        currency : typing.Optional[Currency]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CardInfo]
            Successful request. Returns the BIN information.
        """
        _response = self._client_wrapper.httpx_client.request(
            "cards/bin-lookup",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "amount": amount,
                "currency": currency,
                "card": convert_and_respect_annotation_metadata(
                    object_=card, annotation=BinLookupCard, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CardInfo,
                    parse_obj_as(
                        type_=CardInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve_fx_rates(
        self,
        *,
        channel: FxRateInquiryChannel,
        processing_terminal_id: str,
        base_amount: int,
        base_currency: Currency,
        payment_method: FxRateInquiryPaymentMethod,
        operator: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FxRate]:
        """
        > **Important:** There are restrictions on which merchants can use this method. For more information, go to [Dynamic Currency Conversion](https://docs.payroc.com/knowledge/card-payments/dynamic-currency-conversion).

        Use this method to check if a card is eligible for Dynamic Currency Conversion (DCC) and to retrieve the conversion rate for a transaction amount. DCC provides a customer with the option to use their card's currency instead of the merchant's currency, for example, in Ireland, an American customer can pay in US dollars instead of Euros.

        The request includes the following:

        - **Payment method** - Card information, a secure token, or digital wallet.
        - **Transaction information** - Amount and currency of the transaction in the merchant's currency.

        If the card is eligible for DCC, our gateway returns the transaction amount in the card's currency and a dccOffer object that contains information about the conversion rate. The dccOffer object contains the following fields that you need when you [run a sale](https://docs.payroc.com/api/schema/card-payments/payments/create) or [unreferenced refund](https://docs.payroc.com/api/schema/card-payments/refunds/create-unreferenced-refund) with DCC:
        - fxAmount
        - fxCurrency
        - fxRate
        - markup
        - accepted
        - offerReference

        Parameters
        ----------
        channel : FxRateInquiryChannel
            Channel that the merchant used to receive payment details for the transaction.

        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        base_amount : int
            Total amount of the transaction in the merchant’s currency. The value is in the currency’s lowest denomination, for example, cents.

        base_currency : Currency

        payment_method : FxRateInquiryPaymentMethod
            Polymorphic object that contains payment details.

            The value of the type parameter determines which variant you should use:
            -    `card` - Payment card details
            -    `secureToken` - Secure token details
            -    `digitalWallet` - Digital wallet details

        operator : typing.Optional[str]
            Operator who ran the transaction.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FxRate]
            Successful request. Returns the currency conversion rate for the transaction.
        """
        _response = self._client_wrapper.httpx_client.request(
            "fx-rates",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "channel": channel,
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "baseAmount": base_amount,
                "baseCurrency": base_currency,
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=FxRateInquiryPaymentMethod, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FxRate,
                    parse_obj_as(
                        type_=FxRate,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawCardsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def verify_card(
        self,
        *,
        idempotency_key: str,
        processing_terminal_id: str,
        card: CardVerificationRequestCard,
        operator: typing.Optional[str] = OMIT,
        customer: typing.Optional[Customer] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CardVerificationResult]:
        """
        Use this method to verify a customer’s card details.

        In the request, send the customer’s card details.

        In the response, our gateway indicates if the card details are valid and if you should use them in follow-on actions.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        card : CardVerificationRequestCard
            Polymorphic object that contains payment details.

        operator : typing.Optional[str]
            Operator who requested to verify the card.

        customer : typing.Optional[Customer]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CardVerificationResult]
            Successful request. Returns the verification status of the card details.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "cards/verify",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=Customer, direction="write"
                ),
                "card": convert_and_respect_annotation_metadata(
                    object_=card, annotation=CardVerificationRequestCard, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CardVerificationResult,
                    parse_obj_as(
                        type_=CardVerificationResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def view_ebt_balance(
        self,
        *,
        processing_terminal_id: str,
        currency: Currency,
        card: BalanceInquiryCard,
        operator: typing.Optional[str] = OMIT,
        customer: typing.Optional[Customer] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Balance]:
        """
        Use this method to view the balance of an Electronic Benefit Transfer (EBT) card.

        If the request is successful, our gateway returns the current balance of an EBT card.

        Parameters
        ----------
        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        currency : Currency

        card : BalanceInquiryCard
            Polymorphic object that contains payment details.

            The value of the type parameter determines which variant you should use:
            -    `card` - Payment card details
            -    `singleUseToken` - Single-use token details

        operator : typing.Optional[str]
            Operator who requested the balance inquiry.

        customer : typing.Optional[Customer]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Balance]
            Successful request. Returns the current balance of the EBT card.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "cards/balance",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "currency": currency,
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=Customer, direction="write"
                ),
                "card": convert_and_respect_annotation_metadata(
                    object_=card, annotation=BalanceInquiryCard, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Balance,
                    parse_obj_as(
                        type_=Balance,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def lookup_bin(
        self,
        *,
        card: BinLookupCard,
        processing_terminal_id: typing.Optional[str] = OMIT,
        amount: typing.Optional[int] = OMIT,
        currency: typing.Optional[Currency] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CardInfo]:
        """
        Use this method to retrieve information about a debit card, a credit card, or an EBT card. If you apply surcharges to transactions, you can also check if the card supports surcharging.

        In the response, our gateway returns the following information about the card:

        - **Card details** - Information about the card, for example, the issuing bank and the masked card number.

        - **Surcharging information** - If you apply a surcharge to transactions, our gateway checks that the card supports surcharging and returns information about the surcharge. For more information about surcharging, go to [Credit card surcharging](https://docs.payroc.com/knowledge/card-payments/credit-card-surcharging).

        Parameters
        ----------
        card : BinLookupCard
            Polymorphic object that contains payment details.

            The value of the type parameter determines which variant you should use:
            -    `card` - Payment card details
            -    `cardBin` - Bank identification number (BIN) of the payment card
            -    `secureToken` - Secure token details
            -    `digitalWallet` - Digital wallet details

        processing_terminal_id : typing.Optional[str]
            Unique identifier that we assigned to the terminal.

        amount : typing.Optional[int]
            Transaction amount that you send to check the surcharge amount. The value is in the currency's lowest denomination, for example, cents.

        currency : typing.Optional[Currency]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CardInfo]
            Successful request. Returns the BIN information.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "cards/bin-lookup",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "amount": amount,
                "currency": currency,
                "card": convert_and_respect_annotation_metadata(
                    object_=card, annotation=BinLookupCard, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CardInfo,
                    parse_obj_as(
                        type_=CardInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve_fx_rates(
        self,
        *,
        channel: FxRateInquiryChannel,
        processing_terminal_id: str,
        base_amount: int,
        base_currency: Currency,
        payment_method: FxRateInquiryPaymentMethod,
        operator: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FxRate]:
        """
        > **Important:** There are restrictions on which merchants can use this method. For more information, go to [Dynamic Currency Conversion](https://docs.payroc.com/knowledge/card-payments/dynamic-currency-conversion).

        Use this method to check if a card is eligible for Dynamic Currency Conversion (DCC) and to retrieve the conversion rate for a transaction amount. DCC provides a customer with the option to use their card's currency instead of the merchant's currency, for example, in Ireland, an American customer can pay in US dollars instead of Euros.

        The request includes the following:

        - **Payment method** - Card information, a secure token, or digital wallet.
        - **Transaction information** - Amount and currency of the transaction in the merchant's currency.

        If the card is eligible for DCC, our gateway returns the transaction amount in the card's currency and a dccOffer object that contains information about the conversion rate. The dccOffer object contains the following fields that you need when you [run a sale](https://docs.payroc.com/api/schema/card-payments/payments/create) or [unreferenced refund](https://docs.payroc.com/api/schema/card-payments/refunds/create-unreferenced-refund) with DCC:
        - fxAmount
        - fxCurrency
        - fxRate
        - markup
        - accepted
        - offerReference

        Parameters
        ----------
        channel : FxRateInquiryChannel
            Channel that the merchant used to receive payment details for the transaction.

        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        base_amount : int
            Total amount of the transaction in the merchant’s currency. The value is in the currency’s lowest denomination, for example, cents.

        base_currency : Currency

        payment_method : FxRateInquiryPaymentMethod
            Polymorphic object that contains payment details.

            The value of the type parameter determines which variant you should use:
            -    `card` - Payment card details
            -    `secureToken` - Secure token details
            -    `digitalWallet` - Digital wallet details

        operator : typing.Optional[str]
            Operator who ran the transaction.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FxRate]
            Successful request. Returns the currency conversion rate for the transaction.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "fx-rates",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "channel": channel,
                "processingTerminalId": processing_terminal_id,
                "operator": operator,
                "baseAmount": base_amount,
                "baseCurrency": base_currency,
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=FxRateInquiryPaymentMethod, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FxRate,
                    parse_obj_as(
                        type_=FxRate,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
