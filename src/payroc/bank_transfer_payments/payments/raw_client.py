# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.custom_pagination import AsyncPayrocPager, SyncPayrocPager
from ...core.datetime_utils import serialize_datetime
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_acceptable_error import NotAcceptableError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ...types.bank_transfer_customer import BankTransferCustomer
from ...types.bank_transfer_payment import BankTransferPayment
from ...types.bank_transfer_payment_paginated_list import BankTransferPaymentPaginatedList
from ...types.bank_transfer_payment_request_order import BankTransferPaymentRequestOrder
from ...types.custom_field import CustomField
from ...types.five_hundred import FiveHundred
from ...types.four_hundred import FourHundred
from ...types.four_hundred_fifteen import FourHundredFifteen
from ...types.four_hundred_four import FourHundredFour
from ...types.four_hundred_nine import FourHundredNine
from ...types.four_hundred_one import FourHundredOne
from ...types.four_hundred_six import FourHundredSix
from ...types.schemas_credential_on_file import SchemasCredentialOnFile
from .types.bank_transfer_payment_request_payment_method import BankTransferPaymentRequestPaymentMethod
from .types.list_payments_request_settlement_state import ListPaymentsRequestSettlementState
from .types.list_payments_request_status_item import ListPaymentsRequestStatusItem
from .types.list_payments_request_type_item import ListPaymentsRequestTypeItem
from .types.representment_payment_method import RepresentmentPaymentMethod

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawPaymentsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        processing_terminal_id: str,
        order_id: typing.Optional[str] = None,
        name_on_account: typing.Optional[str] = None,
        last_4: typing.Optional[str] = None,
        type: typing.Optional[
            typing.Union[ListPaymentsRequestTypeItem, typing.Sequence[ListPaymentsRequestTypeItem]]
        ] = None,
        status: typing.Optional[
            typing.Union[ListPaymentsRequestStatusItem, typing.Sequence[ListPaymentsRequestStatusItem]]
        ] = None,
        date_from: typing.Optional[dt.datetime] = None,
        date_to: typing.Optional[dt.datetime] = None,
        settlement_state: typing.Optional[ListPaymentsRequestSettlementState] = None,
        settlement_date: typing.Optional[dt.date] = None,
        payment_link_id: typing.Optional[str] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPayrocPager[BankTransferPayment, BankTransferPaymentPaginatedList]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of payments.

        **Note:** If you want to view the details of a specific payment and you have its paymentId, use our [Retrieve Payment](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/retrieve) method.

        Use query parameters to filter the list of results that we return, for example, to search for payments for a customer, a date range, or a settlement state.

        Our gateway returns the following information about each payment in the list:

        - Order details, including the transaction amount and when it was processed.
        - Bank account details, including the customer’s name and account number.
        - Customer's details, including the customer’s phone number.
        - Transaction details, including any refunds or re-presentments.

        For each transaction, we also return the paymentId and an optional secureTokenId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : str
            Filter results by the unique identifier that we assigned to the terminal.

        order_id : typing.Optional[str]
            Filter results by the order ID of the payment.

        name_on_account : typing.Optional[str]
            Filter results by the account holder's name.

        last_4 : typing.Optional[str]
            Filter results by the last four digits of the account number.

        type : typing.Optional[typing.Union[ListPaymentsRequestTypeItem, typing.Sequence[ListPaymentsRequestTypeItem]]]
            Filter results by transaction type.

        status : typing.Optional[typing.Union[ListPaymentsRequestStatusItem, typing.Sequence[ListPaymentsRequestStatusItem]]]
            Filter results by the status of the payment.

        date_from : typing.Optional[dt.datetime]
            Filter results by payments that the merchant ran after a specific date. The value follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        date_to : typing.Optional[dt.datetime]
            Filter results by payments that the merchant ran before a specific date. The value follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        settlement_state : typing.Optional[ListPaymentsRequestSettlementState]
            Filter results by the settlement status.

        settlement_date : typing.Optional[dt.date]
            Filter results by the settlement date. Send a value in **YYYY-MM-DD** format.

        payment_link_id : typing.Optional[str]
            Filter results by the paymentLinkId.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPayrocPager[BankTransferPayment, BankTransferPaymentPaginatedList]
            Successful request. Returns a list of payments.
        """
        _response = self._client_wrapper.httpx_client.request(
            "bank-transfer-payments",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "processingTerminalId": processing_terminal_id,
                "orderId": order_id,
                "nameOnAccount": name_on_account,
                "last4": last_4,
                "type": type,
                "status": status,
                "dateFrom": serialize_datetime(date_from) if date_from is not None else None,
                "dateTo": serialize_datetime(date_to) if date_to is not None else None,
                "settlementState": settlement_state,
                "settlementDate": str(settlement_date) if settlement_date is not None else None,
                "paymentLinkId": payment_link_id,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    BankTransferPaymentPaginatedList,
                    parse_obj_as(
                        type_=BankTransferPaymentPaginatedList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return SyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        idempotency_key: str,
        processing_terminal_id: str,
        order: BankTransferPaymentRequestOrder,
        payment_method: BankTransferPaymentRequestPaymentMethod,
        customer: typing.Optional[BankTransferCustomer] = OMIT,
        credential_on_file: typing.Optional[SchemasCredentialOnFile] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BankTransferPayment]:
        """
        Use this method to run a sale with a customer's bank account details.

        In the response, our gateway returns information about the bank transfer payment and a paymentId, which you need for the following methods:
        -    [Retrieve payment](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/retrieve) - View the details of the bank transfer payment.
        -    [Reverse payment](https://docs.payroc.com/api/schema/bank-transfer-payments/refunds/reverse-payment) - Cancel the bank transfer payment if it's an open batch.
        -    [Refund payment](https://docs.payroc.com/api/schema/bank-transfer-payments/refunds/refund) - Run a referenced refund to return funds to the customer's bank account.

        **Payment methods**

        Our gateway accepts the following payment methods:
        -    Automated clearing house (ACH) details
        -    Pre-authorized debit (PAD) details

        You can also use [secure tokens](https://docs.payroc.com/api/schema/payments/secure-tokens/overview) and [single-use tokens](https://docs.payroc.com/api/schema/tokenization/single-use-tokens/create) that you created from ACH details or PAD details.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        order : BankTransferPaymentRequestOrder

        payment_method : BankTransferPaymentRequestPaymentMethod
            Object that contains information about the customer's payment details.

        customer : typing.Optional[BankTransferCustomer]

        credential_on_file : typing.Optional[SchemasCredentialOnFile]

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BankTransferPayment]
            Successful request. We processed the sale.
        """
        _response = self._client_wrapper.httpx_client.request(
            "bank-transfer-payments",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=BankTransferPaymentRequestOrder, direction="write"
                ),
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=BankTransferCustomer, direction="write"
                ),
                "credentialOnFile": convert_and_respect_annotation_metadata(
                    object_=credential_on_file, annotation=SchemasCredentialOnFile, direction="write"
                ),
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=BankTransferPaymentRequestPaymentMethod, direction="write"
                ),
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BankTransferPayment,
                    parse_obj_as(
                        type_=BankTransferPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self, payment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[BankTransferPayment]:
        """
        Use this method to retrieve information about a bank transfer payment.

        To retrieve a payment, you need its paymentId. Our gateway returned the paymentId in the response of the [Create Payment](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/create) method.

        Note: If you don’t have the paymentId, use our [List Payments](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/list) method to search for the payment.

        Our gateway returns the following information about the payment:

        -    Order details, including the transaction amount and when it was processed.
        -    Bank account details, including the customer’s name and account number.
        -    Customer’s details, including the customer’s phone number.
        -    Transaction details, including any refunds or re-presentments.

        If the merchant saved the customer’s bank account details, our gateway returns a secureTokenID, which you can use to perform follow-on actions.

        Parameters
        ----------
        payment_id : str
            Unique identifier that our gateway assigned to the payment.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BankTransferPayment]
            Successful request. Returns the specific payment.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"bank-transfer-payments/{jsonable_encoder(payment_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BankTransferPayment,
                    parse_obj_as(
                        type_=BankTransferPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def represent(
        self,
        payment_id: str,
        *,
        idempotency_key: str,
        payment_method: typing.Optional[RepresentmentPaymentMethod] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BankTransferPayment]:
        """
        Use this method to re-present an ACH payment.

        To re-present a payment, you need the paymentId of the return. To get the paymentId of the return, complete the following steps:

        1.    Use our [Retrieve Payment](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/retrieve) method  to view the details of the original payment.
        2.    From the [returns object](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/retrieve#response.body.returns) in the response, get the paymentId of the return.

        Our gateway uses the bank account details from the original payment. If you want to update the customer's bank account details, send the new bank account details in the request.

        If your request is successful, our gateway re-presents the payment.

        Parameters
        ----------
        payment_id : str
            Unique identifier that our gateway assigned to the payment.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        payment_method : typing.Optional[RepresentmentPaymentMethod]
            Object that contains information about the customer's payment details.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BankTransferPayment]
            Successful request. We processed the payment.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"bank-transfer-payments/{jsonable_encoder(payment_id)}/represent",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=RepresentmentPaymentMethod, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BankTransferPayment,
                    parse_obj_as(
                        type_=BankTransferPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawPaymentsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        processing_terminal_id: str,
        order_id: typing.Optional[str] = None,
        name_on_account: typing.Optional[str] = None,
        last_4: typing.Optional[str] = None,
        type: typing.Optional[
            typing.Union[ListPaymentsRequestTypeItem, typing.Sequence[ListPaymentsRequestTypeItem]]
        ] = None,
        status: typing.Optional[
            typing.Union[ListPaymentsRequestStatusItem, typing.Sequence[ListPaymentsRequestStatusItem]]
        ] = None,
        date_from: typing.Optional[dt.datetime] = None,
        date_to: typing.Optional[dt.datetime] = None,
        settlement_state: typing.Optional[ListPaymentsRequestSettlementState] = None,
        settlement_date: typing.Optional[dt.date] = None,
        payment_link_id: typing.Optional[str] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPayrocPager[BankTransferPayment, BankTransferPaymentPaginatedList]:
        """
        Use this method to return a [paginated](https://docs.payroc.com/api/pagination) list of payments.

        **Note:** If you want to view the details of a specific payment and you have its paymentId, use our [Retrieve Payment](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/retrieve) method.

        Use query parameters to filter the list of results that we return, for example, to search for payments for a customer, a date range, or a settlement state.

        Our gateway returns the following information about each payment in the list:

        - Order details, including the transaction amount and when it was processed.
        - Bank account details, including the customer’s name and account number.
        - Customer's details, including the customer’s phone number.
        - Transaction details, including any refunds or re-presentments.

        For each transaction, we also return the paymentId and an optional secureTokenId, which you can use to perform follow-on actions.

        Parameters
        ----------
        processing_terminal_id : str
            Filter results by the unique identifier that we assigned to the terminal.

        order_id : typing.Optional[str]
            Filter results by the order ID of the payment.

        name_on_account : typing.Optional[str]
            Filter results by the account holder's name.

        last_4 : typing.Optional[str]
            Filter results by the last four digits of the account number.

        type : typing.Optional[typing.Union[ListPaymentsRequestTypeItem, typing.Sequence[ListPaymentsRequestTypeItem]]]
            Filter results by transaction type.

        status : typing.Optional[typing.Union[ListPaymentsRequestStatusItem, typing.Sequence[ListPaymentsRequestStatusItem]]]
            Filter results by the status of the payment.

        date_from : typing.Optional[dt.datetime]
            Filter results by payments that the merchant ran after a specific date. The value follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        date_to : typing.Optional[dt.datetime]
            Filter results by payments that the merchant ran before a specific date. The value follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.

        settlement_state : typing.Optional[ListPaymentsRequestSettlementState]
            Filter results by the settlement status.

        settlement_date : typing.Optional[dt.date]
            Filter results by the settlement date. Send a value in **YYYY-MM-DD** format.

        payment_link_id : typing.Optional[str]
            Filter results by the paymentLinkId.

        before : typing.Optional[str]
            Return the previous page of results before the value that you specify.

            You can’t send the before parameter in the same request as the after parameter.

        after : typing.Optional[str]
            Return the next page of results after the value that you specify.

            You can’t send the after parameter in the same request as the before parameter.

        limit : typing.Optional[int]
            Limit the maximum number of results that we return for each page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPayrocPager[BankTransferPayment, BankTransferPaymentPaginatedList]
            Successful request. Returns a list of payments.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "bank-transfer-payments",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            params={
                "processingTerminalId": processing_terminal_id,
                "orderId": order_id,
                "nameOnAccount": name_on_account,
                "last4": last_4,
                "type": type,
                "status": status,
                "dateFrom": serialize_datetime(date_from) if date_from is not None else None,
                "dateTo": serialize_datetime(date_to) if date_to is not None else None,
                "settlementState": settlement_state,
                "settlementDate": str(settlement_date) if settlement_date is not None else None,
                "paymentLinkId": payment_link_id,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    BankTransferPaymentPaginatedList,
                    parse_obj_as(
                        type_=BankTransferPaymentPaginatedList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncPayrocPager(initial_response=_parsed_response, client_wrapper=self._client_wrapper)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        idempotency_key: str,
        processing_terminal_id: str,
        order: BankTransferPaymentRequestOrder,
        payment_method: BankTransferPaymentRequestPaymentMethod,
        customer: typing.Optional[BankTransferCustomer] = OMIT,
        credential_on_file: typing.Optional[SchemasCredentialOnFile] = OMIT,
        custom_fields: typing.Optional[typing.Sequence[CustomField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BankTransferPayment]:
        """
        Use this method to run a sale with a customer's bank account details.

        In the response, our gateway returns information about the bank transfer payment and a paymentId, which you need for the following methods:
        -    [Retrieve payment](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/retrieve) - View the details of the bank transfer payment.
        -    [Reverse payment](https://docs.payroc.com/api/schema/bank-transfer-payments/refunds/reverse-payment) - Cancel the bank transfer payment if it's an open batch.
        -    [Refund payment](https://docs.payroc.com/api/schema/bank-transfer-payments/refunds/refund) - Run a referenced refund to return funds to the customer's bank account.

        **Payment methods**

        Our gateway accepts the following payment methods:
        -    Automated clearing house (ACH) details
        -    Pre-authorized debit (PAD) details

        You can also use [secure tokens](https://docs.payroc.com/api/schema/payments/secure-tokens/overview) and [single-use tokens](https://docs.payroc.com/api/schema/tokenization/single-use-tokens/create) that you created from ACH details or PAD details.

        Parameters
        ----------
        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        processing_terminal_id : str
            Unique identifier that we assigned to the terminal.

        order : BankTransferPaymentRequestOrder

        payment_method : BankTransferPaymentRequestPaymentMethod
            Object that contains information about the customer's payment details.

        customer : typing.Optional[BankTransferCustomer]

        credential_on_file : typing.Optional[SchemasCredentialOnFile]

        custom_fields : typing.Optional[typing.Sequence[CustomField]]
            Array of customField objects.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BankTransferPayment]
            Successful request. We processed the sale.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "bank-transfer-payments",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "processingTerminalId": processing_terminal_id,
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=BankTransferPaymentRequestOrder, direction="write"
                ),
                "customer": convert_and_respect_annotation_metadata(
                    object_=customer, annotation=BankTransferCustomer, direction="write"
                ),
                "credentialOnFile": convert_and_respect_annotation_metadata(
                    object_=credential_on_file, annotation=SchemasCredentialOnFile, direction="write"
                ),
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=BankTransferPaymentRequestPaymentMethod, direction="write"
                ),
                "customFields": convert_and_respect_annotation_metadata(
                    object_=custom_fields, annotation=typing.Sequence[CustomField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BankTransferPayment,
                    parse_obj_as(
                        type_=BankTransferPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self, payment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[BankTransferPayment]:
        """
        Use this method to retrieve information about a bank transfer payment.

        To retrieve a payment, you need its paymentId. Our gateway returned the paymentId in the response of the [Create Payment](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/create) method.

        Note: If you don’t have the paymentId, use our [List Payments](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/list) method to search for the payment.

        Our gateway returns the following information about the payment:

        -    Order details, including the transaction amount and when it was processed.
        -    Bank account details, including the customer’s name and account number.
        -    Customer’s details, including the customer’s phone number.
        -    Transaction details, including any refunds or re-presentments.

        If the merchant saved the customer’s bank account details, our gateway returns a secureTokenID, which you can use to perform follow-on actions.

        Parameters
        ----------
        payment_id : str
            Unique identifier that our gateway assigned to the payment.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BankTransferPayment]
            Successful request. Returns the specific payment.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"bank-transfer-payments/{jsonable_encoder(payment_id)}",
            base_url=self._client_wrapper.get_environment().api,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BankTransferPayment,
                    parse_obj_as(
                        type_=BankTransferPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def represent(
        self,
        payment_id: str,
        *,
        idempotency_key: str,
        payment_method: typing.Optional[RepresentmentPaymentMethod] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BankTransferPayment]:
        """
        Use this method to re-present an ACH payment.

        To re-present a payment, you need the paymentId of the return. To get the paymentId of the return, complete the following steps:

        1.    Use our [Retrieve Payment](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/retrieve) method  to view the details of the original payment.
        2.    From the [returns object](https://docs.payroc.com/api/schema/bank-transfer-payments/payments/retrieve#response.body.returns) in the response, get the paymentId of the return.

        Our gateway uses the bank account details from the original payment. If you want to update the customer's bank account details, send the new bank account details in the request.

        If your request is successful, our gateway re-presents the payment.

        Parameters
        ----------
        payment_id : str
            Unique identifier that our gateway assigned to the payment.

        idempotency_key : str
            Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).

        payment_method : typing.Optional[RepresentmentPaymentMethod]
            Object that contains information about the customer's payment details.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BankTransferPayment]
            Successful request. We processed the payment.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"bank-transfer-payments/{jsonable_encoder(payment_id)}/represent",
            base_url=self._client_wrapper.get_environment().api,
            method="POST",
            json={
                "paymentMethod": convert_and_respect_annotation_metadata(
                    object_=payment_method, annotation=RepresentmentPaymentMethod, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BankTransferPayment,
                    parse_obj_as(
                        type_=BankTransferPayment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundred,
                        parse_obj_as(
                            type_=FourHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredOne,
                        parse_obj_as(
                            type_=FourHundredOne,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFour,
                        parse_obj_as(
                            type_=FourHundredFour,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredSix,
                        parse_obj_as(
                            type_=FourHundredSix,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredNine,
                        parse_obj_as(
                            type_=FourHundredNine,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FourHundredFifteen,
                        parse_obj_as(
                            type_=FourHundredFifteen,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        FiveHundred,
                        parse_obj_as(
                            type_=FiveHundred,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
